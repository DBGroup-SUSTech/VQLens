{"remainingRequest":"/home/yansha/VDProject/VDFrontend/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/yansha/VDProject/VDFrontend/src/views/MainView/MiddleMainView/DistributionView.vue?vue&type=script&lang=js","dependencies":[{"path":"/home/yansha/VDProject/VDFrontend/src/views/MainView/MiddleMainView/DistributionView.vue","mtime":1744442733408},{"path":"/home/yansha/VDProject/VDFrontend/node_modules/cache-loader/dist/cjs.js","mtime":1735202380381},{"path":"/home/yansha/VDProject/VDFrontend/node_modules/babel-loader/lib/index.js","mtime":1735202380921},{"path":"/home/yansha/VDProject/VDFrontend/node_modules/babel-loader/lib/index.js","mtime":1735202380921},{"path":"/home/yansha/VDProject/VDFrontend/node_modules/cache-loader/dist/cjs.js","mtime":1735202380381},{"path":"/home/yansha/VDProject/VDFrontend/node_modules/vue-loader/lib/index.js","mtime":1735202381045}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CmltcG9ydCB7IG1hcFN0YXRlIH0gZnJvbSAidnVleCI7CmltcG9ydCB7IGNvbmZpZyB9IGZyb20gJ0AvY29uZmlnL2NvbmZpZyc7CmltcG9ydCBjcmVhdGVSZWdsIGZyb20gJ3JlZ2wnOwppbXBvcnQgZDMgZnJvbSAnLi4vLi4vLi4vdXRpbHMvZDMtaW1wb3J0JzsKaW1wb3J0IHsgYW55VHJ1ZSwgYWxsVHJ1ZSB9IGZyb20gJy4uLy4uLy4uL2NvbXBvbmVudHMvRW1iZWRkaW5nL0VtYmVkZGluZyc7CgppbXBvcnQgTG9hZGVyV29ya2VyIGZyb20gJy4uLy4uLy4uL2NvbXBvbmVudHMvRW1iZWRkaW5nL3dvcmtlcnMvbG9hZGVyLndvcmtlci5qcyc7CmltcG9ydCBUcmVlV29ya2VyIGZyb20gJy4uLy4uLy4uL2NvbXBvbmVudHMvRW1iZWRkaW5nL3dvcmtlcnMvdHJlZS53b3JrZXIuanMnOwppbXBvcnQgU2VhY2hlcldvcmtlciBmcm9tICcuLi8uLi8uLi9jb21wb25lbnRzL0VtYmVkZGluZy93b3JrZXJzL3NlYXJjaC53b3JrZXIuanMnOwoKaW1wb3J0ICogYXMgRW1iZWRkZXIgZnJvbSAnLi4vLi4vLi4vY29tcG9uZW50cy9FbWJlZGRpbmcvRW1iZWRkaW5nJzsKaW1wb3J0ICogYXMgUG9pbnREcmF3ZXIgZnJvbSAnLi4vLi4vLi4vY29tcG9uZW50cy9FbWJlZGRpbmcvRW1iZWRkaW5nUG9pbnRXZWJHTCc7CmltcG9ydCAqIGFzIExhYmVsZXIgZnJvbSAnLi4vLi4vLi4vY29tcG9uZW50cy9FbWJlZGRpbmcvRW1iZWRkaW5nTGFiZWwnOwppbXBvcnQgeyBIT1ZFUl9SQURJVVMgfSBmcm9tICcuLi8uLi8uLi91dGlscy91dGlscyc7CgpleHBvcnQgZGVmYXVsdCB7CiAgICBuYW1lOiAiRGlzdHJpYnV0aW9uVmlldyIsCiAgICBjb21wb25lbnRzOiB7CgogICAgfSwKICAgIGRhdGEoKSB7CiAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgY29tcG9uZW50OiBudWxsLAoKICAgICAgICAgICAgc3ZnOiBudWxsLAogICAgICAgICAgICBzdmdGdWxsU2l6ZTogeyB3aWR0aDogMCwgaGVpZ2h0OiAwIH0sCiAgICAgICAgICAgIHN2Z1NpemU6IHsgd2lkdGg6IDAsIGhlaWdodDogMCB9LAogICAgICAgICAgICBzdmdQYWRkaW5nOiB7IHRvcDogMCwgYm90dG9tOiAwLCBsZWZ0OiAwLCByaWdodDogMCB9LAoKICAgICAgICAgICAgdG9wU3ZnOiBudWxsLAogICAgICAgICAgICB0b3BpY0NhbnZhc2VzOiBbXSwKCiAgICAgICAgICAgIC8vIHBvaW50cwogICAgICAgICAgICBwb2ludENhbnZhczogbnVsbCwKICAgICAgICAgICAgcG9pbnRSZWdsOiBudWxsLAogICAgICAgICAgICBmcm9udFBvc2l0aW9uQnVmZmVyOiBudWxsLAogICAgICAgICAgICBmcm9udFRleHR1cmVDb29yZGluYXRlQnVmZmVyOiBudWxsLAogICAgICAgICAgICBmcm9udEJ1ZmZlclBvaW50U2l6ZTogMCwKCiAgICAgICAgICAgIC8vIHNlYXJjaCB0cmFjZQogICAgICAgICAgICBzZWFyY2hQb2ludENhbnZhczogbnVsbCwKICAgICAgICAgICAgc2VhcmNoUG9pbnRSZWdsOiBudWxsLAogICAgICAgICAgICBzZWFyY2hQb2ludFBvc2l0aW9uQnVmZmVyOiBudWxsLAogICAgICAgICAgICBzZWFyY2hQb2ludFRleHR1cmVDb29yZGluYXRlQnVmZmVyOiBudWxsLAogICAgICAgICAgICBzZWFyY2hQb2ludFJlc3VsdHM6IHsgInRyYWNlUG9pbnRzIjogW10sICJjb25uZWN0RGF0YSI6IFtdLCAic3RhcnROb2RlIjogW10sICJkaWZmU0xpc3QiOiBbXSwgImRpZmZHTGlzdCI6IFtdLCAiaW50ZXJMaXN0IjogW10gfSwKCiAgICAgICAgICAgIC8vIHNlYXJjaCB0YWJsZQogICAgICAgICAgICBzZWFyY2hQb2ludENhbnZhczI6IG51bGwsCiAgICAgICAgICAgIHNlYXJjaFBvaW50UmVnbDI6IG51bGwsCiAgICAgICAgICAgIHNlYXJjaFBvaW50UG9zaXRpb25CdWZmZXIyOiBudWxsLAogICAgICAgICAgICBzZWFyY2hQb2ludFRleHR1cmVDb29yZGluYXRlQnVmZmVyMjogbnVsbCwKICAgICAgICAgICAgc2VhcmNoUG9pbnRSZXN1bHRzMjogW10sCgogICAgICAgICAgICAvLyBUb29sdGlwcwogICAgICAgICAgICB0b29sdGlwVG9wOiBudWxsLAogICAgICAgICAgICB0b29sdGlwQm90dG9tOiBudWxsLAogICAgICAgICAgICBob3ZlclBvaW50OiBudWxsLAoKICAgICAgICAgICAgeFNjYWxlOiBkMy5zY2FsZUxpbmVhcigpLAogICAgICAgICAgICB5U2NhbGU6IGQzLnNjYWxlTGluZWFyKCksCgogICAgICAgICAgICAvLyB6b29taW5nCiAgICAgICAgICAgIHpvb206IG51bGwsIC8vIGQzLlpvb21CZWhhdmlvcjxIVE1MRWxlbWVudCwgdW5rbm93bj4KICAgICAgICAgICAgaW5pdFpvb21UcmFuc2Zvcm06IG51bGwsCiAgICAgICAgICAgIGN1clpvb21UcmFuc2Zvcm06IGQzLnpvb21JZGVudGl0eSwKICAgICAgICAgICAgY3VyWm9vbUxldmVsOiAxLAoKICAgICAgICAgICAgLy8gaW50ZXJhY3Rpb24KICAgICAgICAgICAgbGFzdE1vdXNlQ2xpZW50UG9zaXRpb246IG51bGwsCiAgICAgICAgICAgIGhpZGVIaWdobGlnaHRzOiBmYWxzZSwKCiAgICAgICAgICAgIC8vIHVzZXIgc2V0dGluZ3MKICAgICAgICAgICAgc2hvd0NvbnRvdXJzOiBbdHJ1ZV0sICAgLy8g5YWI57uZ5LiA5Lqb6buY6K6k55qE5YC85Ye65p2lCiAgICAgICAgICAgIHNob3dHcmlkOiB0cnVlLAogICAgICAgICAgICBzaG93UG9pbnRzOiBbdHJ1ZV0sCiAgICAgICAgICAgIHNob3dQb2ludHNfYmFjazogZmFsc2UsCiAgICAgICAgICAgIHNob3dMYWJlbDogZmFsc2UsCiAgICAgICAgICAgIHNob3dUcmFjZTogdHJ1ZSwKCiAgICAgICAgICAgIC8vIGRhdGEKICAgICAgICAgICAgZGF0YVVSTHM6IG51bGwsCiAgICAgICAgICAgIHByb21wdFBvaW50czogW10sCiAgICAgICAgICAgIGdyaWREYXRhOiBudWxsLAogICAgICAgICAgICB0aWxlRGF0YTogbnVsbCwKICAgICAgICAgICAgY29udG91cnM6IG51bGwsCiAgICAgICAgICAgIGdyb3VwQ29udG91cjogbnVsbCwKICAgICAgICAgICAgY29udG91cnNJbml0aWFsaXplZDogZmFsc2UsCiAgICAgICAgICAgIGxvYWRlZFBvaW50Q291bnQ6IDEsCgogICAgICAgICAgICAvLyBUaW1lCiAgICAgICAgICAgIHRpbWVUZXh0dXJlTWFwOiBudWxsLAoKICAgICAgICAgICAgLy8gR3JvdXAKICAgICAgICAgICAgZ3JvdXBOYW1lczogW10sCgogICAgICAgICAgICAvLyBzZWFyY2gKICAgICAgICAgICAgY29tcGxldGVkU2VhcmNoUXVlcnlJRDogbnVsbCwKCiAgICAgICAgICAgIC8vIHNjYXR0ZXIgcGxvdAogICAgICAgICAgICBsYXN0UmVmaWxsSUQ6IDAsCiAgICAgICAgICAgIGxzYXRSZWZpbGxUaW1lOiAwLAogICAgICAgICAgICB3ZWJHTE1hdHJpY2VzOiBudWxsLAogICAgICAgICAgICBjdXJQb2ludFdpZHRoOiAxLAoKICAgICAgICAgICAgLy8gZGlzcGxheSBsYWJlbHMKICAgICAgICAgICAgdG9waWNMZXZlbFRyZWVzOiBuZXcgTWFwKCksCiAgICAgICAgICAgIGxhc3RHcmlkVHJlZUxldmVsczogW10sCgogICAgICAgICAgICAvLyBXZWIgd29ya2VycwogICAgICAgICAgICBsb2FkZXJXb3JrZXI6IG51bGwsCiAgICAgICAgICAgIHRyZWVXb3JrZXI6IG51bGwsCgogICAgICAgICAgICAvLyBzdG9yZQogICAgICAgICAgICBmb290ZXJTdG9yZVZhbHVlOiB7IHhTY2FsZTogbnVsbCwgZW1iZWRkaW5nTmFtZTogbnVsbCwgbnVtUG9pbnRzOiBudWxsIH0sCgoKICAgICAgICAgICAgLy8gb3RoZXIgdG9wCiAgICAgICAgICAgIERFQlVHOiBjb25maWcuZGVidWcsCgogICAgICAgICAgICBoYW5kbGVkRm9vdGVyTWVzc2FnZUlEOiAwLAoKCiAgICAgICAgICAgIC8vIGNhbnZhcyBwb2ludHMgZGlzCiAgICAgICAgICAgIHBvaW50c0RpY3Q6IFt7fV0sCgoKICAgICAgICB9OwogICAgfSwKICAgIG1vdW50ZWQoKSB7CgogICAgICAgIHRoaXMuaW5pdCgpOwoKICAgIH0sCiAgICBtZXRob2RzOiB7CiAgICAgICAgaW5pdCgpIHsKCiAgICAgICAgICAgIGNvbnN0IGRhZyA9IHRoaXMuJHJlZnMuZGlzdHJpYnV0aW9uTWFpbjsKICAgICAgICAgICAgdGhpcy5zdmdGdWxsU2l6ZS5oZWlnaHQgPSBkYWcuY2xpZW50SGVpZ2h0OwogICAgICAgICAgICB0aGlzLnN2Z0Z1bGxTaXplLndpZHRoID0gZGFnLmNsaWVudFdpZHRoOwoKICAgICAgICAgICAgY29uc29sZS5sb2coIuWvuWRpcyDnmoTlpKflsI/ov5vooYzovpPlh7oiLCB0aGlzLnN2Z0Z1bGxTaXplLmhlaWdodCwgdGhpcy5zdmdGdWxsU2l6ZS53aWR0aCkKCiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50ID0gZDMuc2VsZWN0KCcuZGlzdHJpYnV0aW9uLW1haW4nKTsKCiAgICAgICAgICAgIC8vIGluaXQgd29ya2VyCiAgICAgICAgICAgIHRoaXMuaW5pdFdvcmtlcigpOwoKICAgICAgICAgICAgLy8gaW5pdCBzdmcgYW5kIGNhbnZhcwogICAgICAgICAgICBjb25zdCBzcXVhcmVDYW52YXNXaWR0aCA9IE1hdGgubWluKAogICAgICAgICAgICAgICAgdGhpcy5zdmdGdWxsU2l6ZS53aWR0aCAtIHRoaXMuc3ZnUGFkZGluZy5sZWZ0IC0gdGhpcy5zdmdQYWRkaW5nLnJpZ2h0LAogICAgICAgICAgICAgICAgdGhpcy5zdmdGdWxsU2l6ZS5oZWlnaHQgLSB0aGlzLnN2Z1BhZGRpbmcudG9wIC0gdGhpcy5zdmdQYWRkaW5nLmJvdHRvbQogICAgICAgICAgICApOwoKICAgICAgICAgICAgdGhpcy5zdmdTaXplID0gewogICAgICAgICAgICAgICAgd2lkdGg6IHNxdWFyZUNhbnZhc1dpZHRoLAogICAgICAgICAgICAgICAgaGVpZ2h0OiBzcXVhcmVDYW52YXNXaWR0aAogICAgICAgICAgICB9OwoKICAgICAgICAgICAgdGhpcy5pbml0VG9wU3ZnKCk7CiAgICAgICAgICAgIHRoaXMuaW5pdENhbnZhcygpOwogICAgICAgICAgICB0aGlzLmluaXRTVkdHcm91cHMoKTsKCiAgICAgICAgICAgIC8vIFJlZ2lzdGVyIHpvb20KICAgICAgICAgICAgdGhpcy56b29tID0gZDMKICAgICAgICAgICAgICAgIC56b29tKCkKICAgICAgICAgICAgICAgIC5leHRlbnQoWwogICAgICAgICAgICAgICAgICAgIFswLCAwXSwKICAgICAgICAgICAgICAgICAgICBbdGhpcy5zdmdTaXplLndpZHRoLCB0aGlzLnN2Z1NpemUuaGVpZ2h0XQogICAgICAgICAgICAgICAgXSkKICAgICAgICAgICAgICAgIC5zY2FsZUV4dGVudChbY29uZmlnLmxheW91dC56b29tU2NhbGVbMF0sIGNvbmZpZy5sYXlvdXQuem9vbVNjYWxlWzFdXSkKICAgICAgICAgICAgICAgIC5pbnRlcnBvbGF0ZShkMy5pbnRlcnBvbGF0ZSkKICAgICAgICAgICAgICAgIC5vbignem9vbScsIChnKSA9PiB7CiAgICAgICAgICAgICAgICAgICAgKGFzeW5jICgpID0+IHsKICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy56b29tZWQoZyk7CiAgICAgICAgICAgICAgICAgICAgfSkoKTsKICAgICAgICAgICAgICAgIH0pCiAgICAgICAgICAgICAgICAub24oJ2VuZCcsICgpID0+IHRoaXMuem9vbUVuZGVkKCkpOwoKICAgICAgICAgICAgdGhpcy50b3BTdmcuY2FsbCh0aGlzLnpvb20pLm9uKCdkYmxjbGljay56b29tJywgbnVsbCk7CgogICAgICAgICAgICB0aGlzLnRvb2x0aXBUb3AgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjcG9wcGVyLXRvb2x0aXAtdG9wJyk7CiAgICAgICAgICAgIHRoaXMudG9vbHRpcEJvdHRvbSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNwb3BwZXItdG9vbHRpcC1ib3R0b20nKTsKCiAgICAgICAgICAgIC8vIGluaXQgZGF0YQogICAgICAgICAgICB0aGlzLmluaXREYXRhKCkudGhlbigoKSA9PiB7CgogICAgICAgICAgICAgICAgRW1iZWRkZXIuZGlzcGxheUdyb3VwQ2hhbmdlZCh0aGlzLCAiSW1hZ2UiKTsKCgogICAgICAgICAgICB9KTsKCiAgICAgICAgfSwKICAgICAgICBhc3luYyBpbml0RGF0YSgpIHsKCiAgICAgICAgICAgIGNvbnN0IGdyaWREYXRhID0gYXdhaXQgZDMuanNvbih0aGlzLiRzdG9yZS5zdGF0ZS5kYXRhVVJMcy5ncmlkKTsKICAgICAgICAgICAgaWYgKGdyaWREYXRhID09PSB1bmRlZmluZWQpIHsKICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdGYWlsIHRvIGxvYWQgZ3JpZCBkYXRhJyk7CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIHRoaXMuZ3JpZERhdGEgPSBncmlkRGF0YTsKCiAgICAgICAgICAgIC8vIEluaXRpYWxpemUgdGhlIGRhdGEgc2NhbGVzCiAgICAgICAgICAgIGNvbnN0IHhSYW5nZSA9IHRoaXMuZ3JpZERhdGEueFJhbmdlOwogICAgICAgICAgICBjb25zdCB5UmFuZ2UgPSB0aGlzLmdyaWREYXRhLnlSYW5nZTsKCiAgICAgICAgICAgIGxldCB4TGVuZ3RoID0geFJhbmdlWzFdIC0geFJhbmdlWzBdOwogICAgICAgICAgICBsZXQgeUxlbmd0aCA9IHlSYW5nZVsxXSAtIHlSYW5nZVswXTsKCiAgICAgICAgICAgIGlmICghdGhpcy5ncmlkRGF0YS5wYWRkZWQpIHsKICAgICAgICAgICAgICAgIC8vIEFkZCBwYWRkaW5nIGZvciB0aGUgZGF0YQogICAgICAgICAgICAgICAgaWYgKHhMZW5ndGggPCB5TGVuZ3RoKSB7CiAgICAgICAgICAgICAgICAgICAgeVJhbmdlWzBdIC09IHlMZW5ndGggLyA1MDsKICAgICAgICAgICAgICAgICAgICB5UmFuZ2VbMV0gKz0geUxlbmd0aCAvIDUwOwogICAgICAgICAgICAgICAgICAgIHlMZW5ndGggPSB5UmFuZ2VbMV0gLSB5UmFuZ2VbMF07CgogICAgICAgICAgICAgICAgICAgIHhSYW5nZVswXSAtPSAoeUxlbmd0aCAtIHhMZW5ndGgpIC8gMjsKICAgICAgICAgICAgICAgICAgICB4UmFuZ2VbMV0gKz0gKHlMZW5ndGggLSB4TGVuZ3RoKSAvIDI7CiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgIC8vIEFkZCBwYWRkaW5nIGZvciB0aGUgZGF0YQogICAgICAgICAgICAgICAgICAgIHhSYW5nZVswXSAtPSB4TGVuZ3RoIC8gNTA7CiAgICAgICAgICAgICAgICAgICAgeFJhbmdlWzFdICs9IHhMZW5ndGggLyA1MDsKICAgICAgICAgICAgICAgICAgICB4TGVuZ3RoID0geFJhbmdlWzFdIC0geFJhbmdlWzBdOwoKICAgICAgICAgICAgICAgICAgICB5UmFuZ2VbMF0gLT0gKHhMZW5ndGggLSB5TGVuZ3RoKSAvIDI7CiAgICAgICAgICAgICAgICAgICAgeVJhbmdlWzFdICs9ICh4TGVuZ3RoIC0geUxlbmd0aCkgLyAyOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CgogICAgICAgICAgICB0aGlzLnhTY2FsZSA9IGQzCiAgICAgICAgICAgICAgICAuc2NhbGVMaW5lYXIoKQogICAgICAgICAgICAgICAgLmRvbWFpbih4UmFuZ2UpCiAgICAgICAgICAgICAgICAucmFuZ2UoWzAsIHRoaXMuc3ZnU2l6ZS53aWR0aF0pOwoKICAgICAgICAgICAgdGhpcy55U2NhbGUgPSBkMwogICAgICAgICAgICAgICAgLnNjYWxlTGluZWFyKCkKICAgICAgICAgICAgICAgIC5kb21haW4oeVJhbmdlKQogICAgICAgICAgICAgICAgLnJhbmdlKFt0aGlzLnN2Z1NpemUuaGVpZ2h0LCAwXSk7CgogICAgICAgICAgICBQb2ludERyYXdlci5kcmF3Q29udG91cih0aGlzKTsgIC8vIOi/meS4quS4gOiIrOaYr+aMh+WImuWImumAieS4reeahOaXtuWAmeebtOaOpeWvueWFqOmDqOaVsOaNru+8jOWNs+ayoeaciSBncm91cCDmlbDmja7nmoTnu5jliLYKCiAgICAgICAgICAgIC8vIENyZWF0ZSBncm91cCByZWxhdGVkIHN0cnVjdHVyZXMgaWYgdGhlIGRhdGEgaGFzIGdyb3VwcwogICAgICAgICAgICBpZiAodGhpcy5ncmlkRGF0YS5ncm91cEdyaWRzICYmIHRoaXMuZ3JpZERhdGEuZ3JvdXBOYW1lcy5sZW5ndGggPiAwKSB7CiAgICAgICAgICAgICAgICB0aGlzLmdyb3VwTmFtZXMgPSB0aGlzLmdyaWREYXRhLmdyb3VwTmFtZXM7CiAgICAgICAgICAgICAgICBjb25zdCB1bWFwR3JvdXAgPSB0aGlzLnN2Zy5zZWxlY3QoJ2cudW1hcC1ncm91cCcpOwoKICAgICAgICAgICAgICAgIC8vIEFkanVzdCB0aGUgZmlyc3QgY29udG91cidzIG5hbWUKICAgICAgICAgICAgICAgIHRoaXMuc2hvd0NvbnRvdXJzID0gW107CiAgICAgICAgICAgICAgICB0aGlzLnNob3dQb2ludHMgPSBbXTsKICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBDb250b3VycyA9IFtdOwoKICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5ncm91cE5hbWVzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGdyb3VwcyB0byB0aGUgY29udHJvbCBzdGF0ZXMKICAgICAgICAgICAgICAgICAgICAvLyAoRGVmYXVsdCBpcyB0byBzaG93IHRoZSBmaXJzdCBncm91cCBvbmx5KQogICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvd0NvbnRvdXJzLnB1c2goaSA9PT0gMCk7ICAgIC8vIOi/memHjOeahOaEj+aAneaYr+WPquacieesrOS4gOS4que7hOaYr+WPr+S7peaYvuekuueahO+8jOWboOS4uum7mOiupOWxleekuuesrOS4gOS4que7hAogICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvd1BvaW50cy5wdXNoKGkgPT09IDApOwoKICAgICAgICAgICAgICAgICAgICAvLyBBZGQgY29udG91ciBlbGVtZW50cyBmb3Igb3RoZXIgZ3JvdXBzCiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMuZ3JvdXBOYW1lc1tpXTsKICAgICAgICAgICAgICAgICAgICB1bWFwR3JvdXAKICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgnZycpCiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIGBjb250b3VyLWdyb3VwLWdlbmVyaWMgY29udG91ci1ncm91cC0ke25hbWV9YCkKICAgICAgICAgICAgICAgICAgICAgICAgLmNsYXNzZWQoJ2hpZGRlbicsIGkgIT09IDApOwoKICAgICAgICAgICAgICAgICAgICAvLyBEcncgdGhlIGdyb3VwIGNvbnRvdXIKICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJDb250b3VyID0gUG9pbnREcmF3ZXIuZHJhd0dyb3VwQ29udG91cih0aGlzLCBuYW1lKTsKICAgICAgICAgICAgICAgICAgICBpZiAoY3VyQ29udG91ciAhPT0gbnVsbCkgewogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdyb3VwQ29udG91cnMucHVzaChjdXJDb250b3VyKTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIC8vIFRlbGwgdGhlIHRyZWUgd29ya2VyIHRvIHByZXBhcmUgdG8gYWRkIHBvaW50cyB0byB0aGUgdHJlZQogICAgICAgICAgICBjb25zdCBncm91cElEcyA9IFtdOwoKICAgICAgICAgICAgaWYgKHRoaXMuZ3JvdXBOYW1lcykgewogICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmdyb3VwTmFtZXMubGVuZ3RoOyBpKyspIHsKICAgICAgICAgICAgICAgICAgICBncm91cElEcy5wdXNoKGkpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CgogICAgICAgICAgICBjb25zdCB0cmVlTWVzc2FnZSA9IHsKICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICdpbml0UXVhZHRyZWUnLAogICAgICAgICAgICAgICAgcGF5bG9hZDogewogICAgICAgICAgICAgICAgICAgIHhSYW5nZTogeFJhbmdlLAogICAgICAgICAgICAgICAgICAgIHlSYW5nZTogeVJhbmdlLAogICAgICAgICAgICAgICAgICAgIGdyb3VwSURzOiBncm91cElEcywKICAgICAgICAgICAgICAgICAgICB0aW1lczogW10KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfTsKCiAgICAgICAgICAgIHRoaXMudHJlZVdvcmtlci5wb3N0TWVzc2FnZSh0cmVlTWVzc2FnZSk7CgogICAgICAgICAgICBmb3IgKGNvbnN0IGxldmVsIG9mIE9iamVjdC5rZXlzKHRoaXMuZ3JpZERhdGEudG9waWMuZGF0YSkpIHsKICAgICAgICAgICAgICAgIGNvbnN0IHRyZWUgPSBkMwogICAgICAgICAgICAgICAgICAgIC5xdWFkdHJlZSgpCiAgICAgICAgICAgICAgICAgICAgLngoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRbMF07IH0pCiAgICAgICAgICAgICAgICAgICAgLnkoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRbMV07IH0pCiAgICAgICAgICAgICAgICAgICAgLmFkZEFsbCh0aGlzLmdyaWREYXRhLnRvcGljLmRhdGFbbGV2ZWxdKTsKICAgICAgICAgICAgICAgIHRoaXMudG9waWNMZXZlbFRyZWVzLnNldChwYXJzZUludChsZXZlbCwgMTApLCB0cmVlKTsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgLy8g5LmL5ZCO5piv5a+5IHRvcGljIGxhYmVsIOeahOe7mOWItu+8jOS5i+WQjui/m+ihjOa3u+WKoAoKCiAgICAgICAgICAgIC8vIEluaXRpYWxpemUgV2ViR0wgbWF0cmljZXMgb25jZSB3ZSBoYXZlIHRoZSBzY2FsZXMKICAgICAgICAgICAgUG9pbnREcmF3ZXIuaW5pdFdlYkdMTWF0cmljZXModGhpcyk7CiAgICAgICAgICAgIFBvaW50RHJhd2VyLmluaXRXZWJHTEJ1ZmZlcnModGhpcyk7CgogICAgICAgIH0sCiAgICAgICAgaW5pdENhbnZhcygpIHsKCiAgICAgICAgICAgIGNvbnN0IGRpc2NvbXBvbmVudCA9IHRoaXMuJHJlZnMuZGlzdHJpYnV0aW9uTWFpbjsKCiAgICAgICAgICAgIHRoaXMuc2VhcmNoUG9pbnRDYW52YXMgPSBkMy5zZWxlY3QoZGlzY29tcG9uZW50KQogICAgICAgICAgICAgICAgLmFwcGVuZCgnY2FudmFzJykKICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdzZWFyY2gtcG9pbnQtY2FudmFzJykKICAgICAgICAgICAgICAgIC5jbGFzc2VkKCdoaWRkZW4nLCB0cnVlKQogICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgdGhpcy5zdmdGdWxsU2l6ZS53aWR0aCkKICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCB0aGlzLnN2Z0Z1bGxTaXplLmhlaWdodCk7CgogICAgICAgICAgICB0aGlzLnNlYXJjaFBvaW50UmVnbCA9IGNyZWF0ZVJlZ2wodGhpcy5zZWFyY2hQb2ludENhbnZhcz8ubm9kZSgpKTsKCiAgICAgICAgICAgIHRoaXMucG9pbnRDYW52YXMgPSBkMy5zZWxlY3QoZGlzY29tcG9uZW50KQogICAgICAgICAgICAgICAgLmFwcGVuZCgnY2FudmFzJykKICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbWJlZGRpbmctY2FudmFzJykKICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIHRoaXMuc3ZnRnVsbFNpemUud2lkdGgpCiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgdGhpcy5zdmdGdWxsU2l6ZS5oZWlnaHQpOwoKICAgICAgICAgICAgdGhpcy5wb2ludFJlZ2wgPSBjcmVhdGVSZWdsKHRoaXMucG9pbnRDYW52YXM/Lm5vZGUoKSk7CgogICAgICAgICAgICB0aGlzLnRvcGljQ2FudmFzZXMgPSBbXTsKICAgICAgICAgICAgZm9yIChjb25zdCBwb3Mgb2YgWyd0b3AnLCAnYm90dG9tJ10pIHsKICAgICAgICAgICAgICAgIHRoaXMudG9waWNDYW52YXNlcy5wdXNoKAogICAgICAgICAgICAgICAgICAgIGQzCiAgICAgICAgICAgICAgICAgICAgICAgIC5zZWxlY3QoZGlzY29tcG9uZW50KQogICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCdjYW52YXMnKQogICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCBgdG9waWMtZ3JpZC1jYW52YXMgJHtwb3N9YCkKICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgYCR7dGhpcy5zdmdGdWxsU2l6ZS53aWR0aH1weGApCiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBgJHt0aGlzLnN2Z0Z1bGxTaXplLmhlaWdodH1weGApCiAgICAgICAgICAgICAgICAgICAgICAgIC5jbGFzc2VkKCdoaWRkZW4nLCAhdGhpcy5zaG93R3JpZCkKICAgICAgICAgICAgICAgICk7CiAgICAgICAgICAgIH0KCiAgICAgICAgfSwKICAgICAgICBpbml0U1ZHR3JvdXBzKCkgewoKICAgICAgICAgICAgdGhpcy5zdmcgPSB0aGlzLmNvbXBvbmVudC5hcHBlbmQoJ3N2ZycpCiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAiZW1iZWRkaW5nLXN2ZyIpCiAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCB0aGlzLnN2Z0Z1bGxTaXplLndpZHRoKQogICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIHRoaXMuc3ZnRnVsbFNpemUuaGVpZ2h0KTsKCgogICAgICAgICAgICBjb25zdCB1bWFwR3JvdXAgPSB0aGlzLnN2ZwogICAgICAgICAgICAgICAgLmFwcGVuZCgnZycpCiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAndW1hcC1ncm91cCcpCiAgICAgICAgICAgICAgICAuYXR0cigKICAgICAgICAgICAgICAgICAgICAndHJhbnNmb3JtJywKICAgICAgICAgICAgICAgICAgICBgdHJhbnNsYXRlKCR7dGhpcy5zdmdQYWRkaW5nLmxlZnR9LCAke3RoaXMuc3ZnUGFkZGluZy50b3B9KWAKICAgICAgICAgICAgICAgICk7CgogICAgICAgICAgICB1bWFwR3JvdXAKICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2cnKQogICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2NvbnRvdXItZ3JvdXAnKQogICAgICAgICAgICAgICAgLmNsYXNzZWQoJ2hpZGRlbicsICF0aGlzLnNob3dDb250b3Vycyk7CgogICAgICAgIH0sCiAgICAgICAgaW5pdFRvcFN2ZygpIHsKCiAgICAgICAgICAgIC8vIOWIm+W7uuS4gOS4qiBTVkcg5YWD57Sg5bm26K6+572u5YW25bGe5oCnCiAgICAgICAgICAgIHRoaXMudG9wU3ZnID0gdGhpcy5jb21wb25lbnQuYXBwZW5kKCdzdmcnKQogICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgInRvcC1zdmciKQogICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgYCR7dGhpcy5zdmdGdWxsU2l6ZS53aWR0aH1weGApCiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgYCR7dGhpcy5zdmdGdWxsU2l6ZS5oZWlnaHR9cHhgKSAvLyDorr7nva7pq5jluqYKICAgICAgICAgICAgICAgIC5vbigncG9pbnRlcm1vdmUnLCBlID0+IHRoaXMubW91c2Vtb3ZlSGFuZGxlcihlKSkKICAgICAgICAgICAgICAgIC5vbignbW91c2VsZWF2ZScsICgpID0+IHsKICAgICAgICAgICAgICAgICAgICBQb2ludERyYXdlci5oaWdobGlnaHRQb2ludCh0aGlzLCB7IHBvaW50OiB1bmRlZmluZWQsIGFuaW1hdGVkOiBmYWxzZSB9KTsKICAgICAgICAgICAgICAgICAgICBMYWJlbGVyLm1vdXNlb3ZlckxhYmVsKHRoaXMsIG51bGwsIG51bGwpOwogICAgICAgICAgICAgICAgfSkKICAgICAgICAgICAgICAgIC5hdHRyKAogICAgICAgICAgICAgICAgICAgICd0cmFuc2Zvcm0nLAogICAgICAgICAgICAgICAgICAgIGB0cmFuc2xhdGUoJHt0aGlzLnN2Z1BhZGRpbmcubGVmdH0sICR7dGhpcy5zdmdQYWRkaW5nLnRvcH0pYAogICAgICAgICAgICAgICAgKTsKCgogICAgICAgICAgICBjb25zdCB0b3BHcm91cCA9IHRoaXMudG9wU3ZnLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ3RvcC1ncm91cCcpOwoKICAgICAgICAgICAgdG9wR3JvdXAKICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3JlY3QnKQogICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ21vdXNlLXRyYWNrLXJlY3QnKQogICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgdGhpcy5zdmdGdWxsU2l6ZS53aWR0aCkKICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCB0aGlzLnN2Z0Z1bGxTaXplLmhlaWdodCk7CgogICAgICAgICAgICBjb25zdCB0b3BDb250ZW50ID0gdG9wR3JvdXAuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAndG9wLWNvbnRlbnQnKTsKCiAgICAgICAgICAgIHRvcENvbnRlbnQuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAndG9waWNzLWJvdHRvbScpOwogICAgICAgICAgICB0b3BDb250ZW50CiAgICAgICAgICAgICAgICAuYXBwZW5kKCdnJykKICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICd0b3BpY3MnKQogICAgICAgICAgICAgICAgLmNsYXNzZWQoJ2hpZGRlbicsICF0aGlzLnNob3dMYWJlbCk7CiAgICAgICAgICAgIHRvcENvbnRlbnQuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAndG9waWNzLXRvcCcpOwogICAgICAgICAgICB0b3BDb250ZW50LmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ2hpZ2hsaWdodHMnKTsKCiAgICAgICAgfSwKICAgICAgICB6b29tZWQoZSkgewoKICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gZS50cmFuc2Zvcm07CiAgICAgICAgICAgIGNvbnN0IHNjYWxlQ2hhbmdlZCA9IHRoaXMuY3VyWm9vbVRyYW5zZm9ybS5rICE9PSB0cmFuc2Zvcm0uazsKICAgICAgICAgICAgdGhpcy5jdXJab29tVHJhbnNmb3JtID0gdHJhbnNmb3JtOwoKICAgICAgICAgICAgLy8gPT09IFRhc2sgKDEpID09PQogICAgICAgICAgICAvLyBUcmFuc2Zvcm0gdGhlIFNWRyBlbGVtZW50cwogICAgICAgICAgICB0aGlzLnN2Zy5zZWxlY3QoJy51bWFwLWdyb3VwJykuYXR0cigndHJhbnNmb3JtJywgdHJhbnNmb3JtLnRvU3RyaW5nKCkpOwoKICAgICAgICAgICAgLy8gVHJhbnNmb3JtIHRoZSB0b3AgU1ZHIGVsZW1lbnRzCiAgICAgICAgICAgIHRoaXMudG9wU3ZnCiAgICAgICAgICAgICAgICAuc2VsZWN0KCcudG9wLWdyb3VwJykKICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCB0cmFuc2Zvcm0udG9TdHJpbmcoKSk7CgogICAgICAgICAgICAvLyBUcmFuc2Zvcm0gdGhlIHZpc2libGUgY2FudmFzIGVsZW1lbnRzCiAgICAgICAgICAgIGNvbnNvbGUubG9nKCLlr7kgc2hvd1BvaW50cyDov5vooYzovpPlh7oiLCB0aGlzLnNob3dQb2ludHMpCiAgICAgICAgICAgIGlmIChhbnlUcnVlKHRoaXMuc2hvd1BvaW50cykpIHsKICAgICAgICAgICAgICAgIGlmICh0aGlzLmZyb250UG9zaXRpb25CdWZmZXIgJiYgdGhpcy5mcm9udFRleHR1cmVDb29yZGluYXRlQnVmZmVyKSB7CiAgICAgICAgICAgICAgICAgICAgUG9pbnREcmF3ZXIuZHJhd1NjYXR0ZXJQbG90KHRoaXMpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CgogICAgICAgICAgICAvLyBUcmFuc2Zvcm0gdGhlIHNlYXJjaCBzY2F0dGVyIHBsb3QKICAgICAgICAgICAgaWYgKHRoaXMuc2hvd1RyYWNlKSB7CgogICAgICAgICAgICAgICAgY29uc29sZS5sb2coInRyYWNlIOaYr+WQpuS8mui/m+ihjOWxleekuiIsIHRoaXMuc2hvd1RyYWNlKQoKICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoUG9pbnRDYW52YXMuY2xhc3NlZCgnaGlkZGVuJywgZmFsc2UpOwogICAgICAgICAgICAgICAgdGhpcy5wb2ludENhbnZhcy5jbGFzc2VkKCdmYWRlZCcsIHRydWUpOwoKICAgICAgICAgICAgICAgIFBvaW50RHJhd2VyLmRyYXdTZWFyY2hTY2F0dGVyUGxvdCh0aGlzKTsKCiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIGlmICh0aGlzLnNlYXJjaFBvaW50UmVzdWx0czIubGVuZ3RoID4gMCkgewoKICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoUG9pbnRDYW52YXMuY2xhc3NlZCgnaGlkZGVuJywgZmFsc2UpOwogICAgICAgICAgICAgICAgdGhpcy5wb2ludENhbnZhcy5jbGFzc2VkKCdmYWRlZCcsIHRydWUpOwoKICAgICAgICAgICAgICAgIFBvaW50RHJhd2VyLmRyYXdTZWFyY2hTY2F0dGVyUGxvdDIodGhpcyk7CgogICAgICAgICAgICB9CgogICAgICAgICAgICBpZiAodGhpcy5zaG93R3JpZCkgewogICAgICAgICAgICAgICAgTGFiZWxlci5yZWRyYXdUb3BpY0dyaWQodGhpcywgbnVsbCk7CiAgICAgICAgICAgIH0KCgogICAgICAgIH0sCiAgICAgICAgLy8gRXZlbnQgaGFuZGxlciBmb3Igem9vbSBlbmRlZAogICAgICAgIHpvb21FbmRlZCgpIHsKICAgICAgICAgICAgY29uc29sZS5sb2coInN2ZyB6b29tIGVuZCAhISEiKQogICAgICAgIH0sCiAgICAgICAgaW5pdFdvcmtlcigpIHsKICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgd2ViIHdvcmtlciB0byBsb2FkIGRhdGEgYW5kIGRlYWwgd2l0aCB0aGUgcXVhZHRyZWUKICAgICAgICAgICAgdGhpcy5sb2FkZXJXb3JrZXIgPSBuZXcgTG9hZGVyV29ya2VyKCk7CiAgICAgICAgICAgIHRoaXMubG9hZGVyV29ya2VyLm9ubWVzc2FnZSA9IChlKSA9PiB7CiAgICAgICAgICAgICAgICB0aGlzLmxvYWRlcldvcmtlck1lc3NhZ2VIYW5kbGVyKGUpOwogICAgICAgICAgICB9OwoKICAgICAgICAgICAgdGhpcy50cmVlV29ya2VyID0gbmV3IFRyZWVXb3JrZXIoKTsKICAgICAgICAgICAgdGhpcy50cmVlV29ya2VyLm9ubWVzc2FnZSA9IChlKSA9PiB7CiAgICAgICAgICAgICAgICB0aGlzLnRyZWVXb3JrZXJNZXNzYWdlSGFuZGxlcihlKTsKICAgICAgICAgICAgfTsKCiAgICAgICAgICAgIC8vIHRoaXMuc2VhcmNoV29ya2VyID0gbmV3IFNlYXJjaFdvcmtlcigpOwogICAgICAgICAgICAvLyB0aGlzLnNlYXJjaFdvcmtlci5vbm1lc3NhZ2UgPSAoZSkgPT4gewogICAgICAgICAgICAvLyAgICAgdGhpcy5zZWFyY2hXb3JrZXJNZXNzYWdlSGFuZGxlcihlKTsKICAgICAgICAgICAgLy8gfTsKICAgICAgICB9LAogICAgICAgIGxvYWRlcldvcmtlck1lc3NhZ2VIYW5kbGVyKGUpIHsKICAgICAgICAgICAgc3dpdGNoIChlLmRhdGEuY29tbWFuZCkgewogICAgICAgICAgICAgICAgY2FzZSAndHJhbnNmZXJMb2FkRGF0YSc6IHsKICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdGhlc2UgcG9pbnRzIHRvIHRoZSBxdWFkdHJlZSBBU0FQCiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJlZU1lc3NhZ2UgPSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICd1cGRhdGVRdWFkdHJlZScsCiAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50czogZS5kYXRhLnBheWxvYWQucG9pbnRzCiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB9OwogICAgICAgICAgICAgICAgICAgIHRoaXMudHJlZVdvcmtlci5wb3N0TWVzc2FnZSh0cmVlTWVzc2FnZSk7CgogICAgICAgICAgICAgICAgICAgIGlmIChlLmRhdGEucGF5bG9hZC5pc0ZpcnN0QmF0Y2gpIHsKCiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgZmlyc3QgYmF0Y2ggcG9pbnRzCiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvbXB0UG9pbnRzID0gZS5kYXRhLnBheWxvYWQucG9pbnRzOwoKCiAgICAgICAgICAgICAgICAgICAgICAgIFBvaW50RHJhd2VyLmluaXRXZWJHTEJ1ZmZlcnModGhpcyk7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbnlUcnVlKHRoaXMuc2hvd1BvaW50cykpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBvaW50RHJhd2VyLmRyYXdTY2F0dGVyUGxvdCh0aGlzKTsKICAgICAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBwb2ludHMgdG8gdGhlIHNlYXJjaCBpbmRleAogICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWFyY2hNZXNzYWdlID0gewogICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZDogJ2FkZFBvaW50cycsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzOiBlLmRhdGEucGF5bG9hZC5wb2ludHMKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgfTsKICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcy5zZWFyY2hXb3JrZXIucG9zdE1lc3NhZ2Uoc2VhcmNoTWVzc2FnZSk7CiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgLy8gQmF0Y2hlcyBhZnRlciB0aGUgZmlyc3QgYmF0Y2gKICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBwb2ludHMgdG8gdGhlIHByb21wdCBwb2ludCBsaXN0CiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1BvaW50cyA9IGUuZGF0YS5wYXlsb2FkLnBvaW50czsKICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBwb2ludCBvZiBuZXdQb2ludHMpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvbXB0UG9pbnRzLnB1c2gocG9pbnQpOwogICAgICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIHBvaW50cyB0byB0aGUgc2VhcmNoIGluZGV4CiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnN0IHNlYXJjaE1lc3NhZ2UgPSB7CiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICBjb21tYW5kOiAnYWRkUG9pbnRzJywKICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgIHBheWxvYWQ6IHsKICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICBwb2ludHM6IG5ld1BvaW50cwogICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAvLyB9OwogICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzLnNlYXJjaFdvcmtlci5wb3N0TWVzc2FnZShzZWFyY2hNZXNzYWdlKTsKCiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgbmV3IHBvaW50cyB0byB0aGUgV2ViR0wgYnVmZmVycwogICAgICAgICAgICAgICAgICAgICAgICBQb2ludERyYXdlci51cGRhdGVXZWJHTEJ1ZmZlcnModGhpcywgbmV3UG9pbnRzKTsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFueVRydWUodGhpcy5zaG93UG9pbnRzKSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgUG9pbnREcmF3ZXIuZHJhd1NjYXR0ZXJQbG90KHRoaXMpOwogICAgICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5kYXRhLnBheWxvYWQuaXNMYXN0QmF0Y2gpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdGaW5pc2hlZCBsb2FkaW5nIGFsbCBkYXRhLicpOwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCLlr7kgdGhpcy5wcm9tcHQg55qE5aSn5bCP6L+b6KGMIiwgdGhpcy5wcm9tcHRQb2ludHMpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdldFBvaW50c0RpcygpOwogICAgICAgICAgICAgICAgICAgICAgICB9CgoKICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgZGF0YSBwb2ludCBjb3VudAogICAgICAgICAgICAgICAgICAgIHRoaXMubG9hZGVkUG9pbnRDb3VudCA9IGUuZGF0YS5wYXlsb2FkLmxvYWRlZFBvaW50Q291bnQ7CgogICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgZm9vdGVyCiAgICAgICAgICAgICAgICAgICAgdGhpcy5mb290ZXJTdG9yZVZhbHVlLm51bVBvaW50cyA9IHRoaXMucHJvbXB0UG9pbnRzLmxlbmd0aDsKICAgICAgICAgICAgICAgICAgICAvLyB0aGlzLmZvb3RlclN0b3JlLnNldCh0aGlzLmZvb3RlclN0b3JlVmFsdWUpOwogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHsKICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdVbmtub3duIG1lc3NhZ2UnLCBlLmRhdGEuY29tbWFuZCk7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICB9LAoKICAgICAgICB0cmVlV29ya2VyTWVzc2FnZUhhbmRsZXIoZSkgewogICAgICAgICAgICBzd2l0Y2ggKGUuZGF0YS5jb21tYW5kKSB7CiAgICAgICAgICAgICAgICBjYXNlICdmaW5pc2hJbml0UXVhZHRyZWUnOiB7CiAgICAgICAgICAgICAgICAgICAgLy8gVGVsbCB0aGUgbG9hZGVyIHdvcmtlciB0byBzdGFydCBsb2FkaW5nIGRhdGEKICAgICAgICAgICAgICAgICAgICAvLyAobmVlZCB0byB3YWl0IHRvIHNldCB1cCB0aGUgcXVhZHRyZWUgdG8gYXZvaWQgcmFjaW5nKQogICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICdzdGFydExvYWREYXRhJywKICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZDogeyB1cmw6IHRoaXMuJHN0b3JlLnN0YXRlLmRhdGFVUkxzLnBvaW50IH0KICAgICAgICAgICAgICAgICAgICB9OwogICAgICAgICAgICAgICAgICAgIHRoaXMubG9hZGVyV29ya2VyLnBvc3RNZXNzYWdlKG1lc3NhZ2UpOwogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgIGNhc2UgJ2ZpbmlzaFF1YWR0cmVlU2VhcmNoJzogewogICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmxhc3RNb3VzZUNsaWVudFBvc2l0aW9uID09PSBudWxsKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbGFzdE1vdXNlQ2xpZW50UG9zaXRpb24gaXMgbnVsbCcpOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgY2xvc2VzdCBwb2ludCBpcyByZWxhdGl2ZWx5IGNsb3NlIHRvIHRoZSBtb3VzZQogICAgICAgICAgICAgICAgICAgIGNvbnN0IGNsb3Nlc3RQb2ludCA9IHN0cnVjdHVyZWRDbG9uZSgKICAgICAgICAgICAgICAgICAgICAgICAgZS5kYXRhLnBheWxvYWQucG9pbnQKICAgICAgICAgICAgICAgICAgICApOwogICAgICAgICAgICAgICAgICAgIGNvbnN0IHNjcmVlblBvaW50WCA9IHRoaXMuY3VyWm9vbVRyYW5zZm9ybS5hcHBseVgoCiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMueFNjYWxlKGNsb3Nlc3RQb2ludC54KQogICAgICAgICAgICAgICAgICAgICk7CiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2NyZWVuUG9pbnRZID0gdGhpcy5jdXJab29tVHJhbnNmb3JtLmFwcGx5WSgKICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy55U2NhbGUoY2xvc2VzdFBvaW50LnkpCiAgICAgICAgICAgICAgICAgICAgKTsKCiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLm1heCgKICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5hYnMoc2NyZWVuUG9pbnRYIC0gdGhpcy5sYXN0TW91c2VDbGllbnRQb3NpdGlvbi54KSwKICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5hYnMoc2NyZWVuUG9pbnRZIC0gdGhpcy5sYXN0TW91c2VDbGllbnRQb3NpdGlvbi55KQogICAgICAgICAgICAgICAgICAgICk7CgogICAgICAgICAgICAgICAgICAgIGNvbnN0IGhpZ2hsaWdodFJhZGl1cyA9IE1hdGgubWF4KAogICAgICAgICAgICAgICAgICAgICAgICAxMCAvIHRoaXMuY3VyWm9vbVRyYW5zZm9ybS5rLAogICAgICAgICAgICAgICAgICAgICAgICAoY29uZmlnLmxheW91dC5zY2F0dGVyRG90UmFkaXVzICoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguZXhwKE1hdGgubG9nKHRoaXMuY3VyWm9vbVRyYW5zZm9ybS5rKSAqIDAuNTUpKSAvCiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3VyWm9vbVRyYW5zZm9ybS5rCiAgICAgICAgICAgICAgICAgICAgKTsKCiAgICAgICAgICAgICAgICAgICAgLy8gSGlnaGxpZ2h0IHRoZSBwb2ludCBpZiBpdCBpcyBjbG9zZSBlbm91Z2ggdG8gdGhlIG1vdXNlCiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VySG92ZXJSYWRpdXMgPSBNYXRoLm1heCgKICAgICAgICAgICAgICAgICAgICAgICAgSE9WRVJfUkFESVVTLAogICAgICAgICAgICAgICAgICAgICAgICBoaWdobGlnaHRSYWRpdXMgKiB0aGlzLmN1clpvb21UcmFuc2Zvcm0uawogICAgICAgICAgICAgICAgICAgICk7CgogICAgICAgICAgICAgICAgICAgIGlmIChkaXN0YW5jZSA8PSBjdXJIb3ZlclJhZGl1cykgewogICAgICAgICAgICAgICAgICAgICAgICBQb2ludERyYXdlci5oaWdobGlnaHRQb2ludCh0aGlzLCB7IHBvaW50OiBjbG9zZXN0UG9pbnQsIGFuaW1hdGVkOiBmYWxzZSB9KTsKICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICBQb2ludERyYXdlci5oaWdobGlnaHRQb2ludCh0aGlzLCB7IHBvaW50OiB1bmRlZmluZWQsIGFuaW1hdGVkOiBmYWxzZSB9KTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CgoKICAgICAgICAgICAgICAgIGNhc2UgJ2ZpbmlzaFF1YWR0cmVlU2VhcmNoQnlJZCc6IHsKCiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGNsb3Nlc3QgcG9pbnQgaXMgcmVsYXRpdmVseSBjbG9zZSB0byB0aGUgbW91c2UKICAgICAgICAgICAgICAgICAgICBjb25zdCBjbG9zZXN0UG9pbnQgPSBzdHJ1Y3R1cmVkQ2xvbmUoCiAgICAgICAgICAgICAgICAgICAgICAgIGUuZGF0YS5wYXlsb2FkLnBvaW50CiAgICAgICAgICAgICAgICAgICAgKTsKICAgICAgICAgICAgICAgICAgICBjb25zdCBzY3JlZW5Qb2ludFggPSB0aGlzLmN1clpvb21UcmFuc2Zvcm0uYXBwbHlYKAogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnhTY2FsZShjbG9zZXN0UG9pbnQueCkKICAgICAgICAgICAgICAgICAgICApOwogICAgICAgICAgICAgICAgICAgIGNvbnN0IHNjcmVlblBvaW50WSA9IHRoaXMuY3VyWm9vbVRyYW5zZm9ybS5hcHBseVkoCiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMueVNjYWxlKGNsb3Nlc3RQb2ludC55KQogICAgICAgICAgICAgICAgICAgICk7CgogICAgICAgICAgICAgICAgICAgIGNvbnN0IGhpZ2hsaWdodFJhZGl1cyA9IE1hdGgubWF4KAogICAgICAgICAgICAgICAgICAgICAgICAxMCAvIHRoaXMuY3VyWm9vbVRyYW5zZm9ybS5rLAogICAgICAgICAgICAgICAgICAgICAgICAoY29uZmlnLmxheW91dC5zY2F0dGVyRG90UmFkaXVzICoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguZXhwKE1hdGgubG9nKHRoaXMuY3VyWm9vbVRyYW5zZm9ybS5rKSAqIDAuNTUpKSAvCiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3VyWm9vbVRyYW5zZm9ybS5rCiAgICAgICAgICAgICAgICAgICAgKTsKCiAgICAgICAgICAgICAgICAgICAgLy8gSGlnaGxpZ2h0IHRoZSBwb2ludCBpZiBpdCBpcyBjbG9zZSBlbm91Z2ggdG8gdGhlIG1vdXNlCiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VySG92ZXJSYWRpdXMgPSBNYXRoLm1heCgKICAgICAgICAgICAgICAgICAgICAgICAgSE9WRVJfUkFESVVTLAogICAgICAgICAgICAgICAgICAgICAgICBoaWdobGlnaHRSYWRpdXMgKiB0aGlzLmN1clpvb21UcmFuc2Zvcm0uawogICAgICAgICAgICAgICAgICAgICk7CgogICAgICAgICAgICAgICAgICAgIGlmIChlLmRhdGEucGF5bG9hZC5wb2ludCkgewogICAgICAgICAgICAgICAgICAgICAgICBQb2ludERyYXdlci5oaWdobGlnaHRQb2ludCh0aGlzLCB7IHBvaW50OiBjbG9zZXN0UG9pbnQsIGFuaW1hdGVkOiBmYWxzZSB9KTsKICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICBQb2ludERyYXdlci5oaWdobGlnaHRQb2ludCh0aGlzLCB7IHBvaW50OiB1bmRlZmluZWQsIGFuaW1hdGVkOiBmYWxzZSB9KTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CgoKCiAgICAgICAgICAgICAgICBkZWZhdWx0OiB7CiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignVW5rbm93biBtZXNzYWdlJywgZS5kYXRhLmNvbW1hbmQpOwogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgfSwKCiAgICAgICAgc2VhcmNoV29ya2VyTWVzc2FnZUhhbmRsZXIoZSkgewogICAgICAgICAgICBzd2l0Y2ggKGUuZGF0YS5jb21tYW5kKSB7CiAgICAgICAgICAgICAgICBjYXNlICdmaW5pc2hRdWVyeSc6IHsKICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHJlc3VsdEluZGV4ZXMgfSA9IGUuZGF0YS5wYXlsb2FkOwogICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdFBvaW50cyA9IFtdOwoKICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJlc3VsdEluZGV4IG9mIHJlc3VsdEluZGV4ZXMpIHsKICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VyUG9pbnQgPSB0aGlzLnByb21wdFBvaW50c1tyZXN1bHRJbmRleF07CiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFBvaW50cy5wdXNoKGN1clBvaW50KTsKICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgc2VhcmNoIHBhbmVsCiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcy5zZWFyY2hCYXJTdG9yZVZhbHVlLnJlc3VsdHMgPSByZXN1bHRQb2ludHM7CiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcy5zZWFyY2hCYXJTdG9yZVZhbHVlLnNob3duID0gdHJ1ZTsKICAgICAgICAgICAgICAgICAgICAvLyB0aGlzLnNlYXJjaEJhclN0b3JlLnNldCh0aGlzLnNlYXJjaEJhclN0b3JlVmFsdWUpOwoKICAgICAgICAgICAgICAgICAgICAvLyBEcmF3IHRoZSBzY2F0dGVyIHBsb3QKICAgICAgICAgICAgICAgICAgICB0aGlzLnNlYXJjaFBvaW50Q2FudmFzLmNsYXNzZWQoJ2hpZGRlbicsIGZhbHNlKTsKICAgICAgICAgICAgICAgICAgICB0aGlzLnNlYXJjaFBvaW50UmVzdWx0cyA9IHJlc3VsdFBvaW50czsKICAgICAgICAgICAgICAgICAgICBQb2ludERyYXdlci5kcmF3U2VhcmNoU2NhdHRlclBsb3QodGhpcyk7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgZGVmYXVsdDogewogICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1Vua25vd24gbWVzc2FnZScsIGUuZGF0YS5jb21tYW5kKTsKICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgIH0sCgogICAgICAgIG1vdXNlb3ZlclBvaW50KHgsIHkpIHsKICAgICAgICAgICAgLy8gSW52ZXJ0IHRvIHRoZSBzdGFnZSBzY2FsZSA9PiBpbnZlcnQgdG8gdGhlIGRhdGEgc2NhbGUKICAgICAgICAgICAgY29uc3QgZGF0YVggPSB0aGlzLnhTY2FsZS5pbnZlcnQodGhpcy5jdXJab29tVHJhbnNmb3JtLmludmVydFgoeCkpOwogICAgICAgICAgICBjb25zdCBkYXRhWSA9IHRoaXMueVNjYWxlLmludmVydCh0aGlzLmN1clpvb21UcmFuc2Zvcm0uaW52ZXJ0WSh5KSk7CgogICAgICAgICAgICAvLyBMZXQgdGhlIHdvcmtlciB0byBzZWFyY2ggdGhlIGNsb3Nlc3QgcG9pbnQgaW4gYSByYWRpdXMKICAgICAgICAgICAgbGV0IGdyb3VwSUQgPSAtMTsKCiAgICAgICAgICAgIGlmICh0aGlzLmdyb3VwTmFtZXMpIHsKICAgICAgICAgICAgICAgIGlmIChhbGxUcnVlKHRoaXMuc2hvd1BvaW50cykpIHsKICAgICAgICAgICAgICAgICAgICBncm91cElEID0gLTE7CiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IE5lZWQgYSBiZXR0ZXIgd2F5IHRvIHNlYXJjaCBzbGljZXMgb2YgZ3JvdXBzIGZvciBtdWx0aSBncm91cHMKICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2hvd1BvaW50cy5sZW5ndGg7IGkrKykgewogICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zaG93UG9pbnRzW2ldKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cElEID0gaTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CgogICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gewogICAgICAgICAgICAgICAgY29tbWFuZDogJ3N0YXJ0UXVhZHRyZWVTZWFyY2gnLAogICAgICAgICAgICAgICAgcGF5bG9hZDogewogICAgICAgICAgICAgICAgICAgIHg6IGRhdGFYLAogICAgICAgICAgICAgICAgICAgIHk6IGRhdGFZLAogICAgICAgICAgICAgICAgICAgIHRpbWU6IHRoaXMudGltZUluc3BlY3RNb2RlICYmIHRoaXMuY3VyVGltZSA/IHRoaXMuY3VyVGltZSA6ICcnLAogICAgICAgICAgICAgICAgICAgIGdyb3VwSUQ6IGdyb3VwSUQsCiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBudWxsCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH07CiAgICAgICAgICAgIHRoaXMudHJlZVdvcmtlci5wb3N0TWVzc2FnZShtZXNzYWdlKTsKICAgICAgICB9LAoKICAgICAgICBtb3VzZW1vdmVIYW5kbGVyKGUpIHsKICAgICAgICAgICAgLy8gU2hvdyB0b29sdGlwIHdoZW4gbW91c2Ugb3ZlciBhIGRhdGEgcG9pbnQgb24gY2FudmFzCiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gdXNlIGNvbG9yIHBpY2tpbmcgdG8gZmlndXJlIG91dCB3aGljaCBwb2ludCBpcyBob3ZlcmVkIG92ZXIKICAgICAgICAgICAgY29uc3QgeCA9IGUub2Zmc2V0WDsKICAgICAgICAgICAgY29uc3QgeSA9IGUub2Zmc2V0WTsKICAgICAgICAgICAgdGhpcy5sYXN0TW91c2VDbGllbnRQb3NpdGlvbiA9IHsgeDogeCwgeTogeSB9OwoKICAgICAgICAgICAgLy8gU2hvdyBwb2ludCBoaWdobGlnaHQKICAgICAgICAgICAgaWYgKGFueVRydWUodGhpcy5zaG93UG9pbnRzKSAmJiAhdGhpcy5oaWRlSGlnaGxpZ2h0cykgewogICAgICAgICAgICAgICAgdGhpcy5tb3VzZW92ZXJQb2ludCh4LCB5KTsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgLy8gU2hvdyBsYWJlbHMKICAgICAgICAgICAgaWYgKCF0aGlzLmhpZGVIaWdobGlnaHRzKSB7CiAgICAgICAgICAgICAgICBMYWJlbGVyLm1vdXNlb3ZlckxhYmVsKHRoaXMsIHgsIHkpOwogICAgICAgICAgICB9CiAgICAgICAgfSwKCiAgICAgICAgZ2V0Q3VyWm9vbUJveCgpIHsKICAgICAgICAgICAgY29uc3QgYm94ID0gewogICAgICAgICAgICAgICAgeDogdGhpcy5jdXJab29tVHJhbnNmb3JtLmludmVydFgoMCksCiAgICAgICAgICAgICAgICB5OiB0aGlzLmN1clpvb21UcmFuc2Zvcm0uaW52ZXJ0WSgwKSwKICAgICAgICAgICAgICAgIHdpZHRoOiBNYXRoLmFicygKICAgICAgICAgICAgICAgICAgICB0aGlzLmN1clpvb21UcmFuc2Zvcm0uaW52ZXJ0WCh0aGlzLnN2Z0Z1bGxTaXplLndpZHRoKSAtCiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJab29tVHJhbnNmb3JtLmludmVydFgoMCkKICAgICAgICAgICAgICAgICksCiAgICAgICAgICAgICAgICBoZWlnaHQ6IE1hdGguYWJzKAogICAgICAgICAgICAgICAgICAgIHRoaXMuY3VyWm9vbVRyYW5zZm9ybS5pbnZlcnRZKHRoaXMuc3ZnRnVsbFNpemUuaGVpZ2h0KSAtCiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJab29tVHJhbnNmb3JtLmludmVydFkoMCkKICAgICAgICAgICAgICAgICkKICAgICAgICAgICAgfTsKICAgICAgICAgICAgcmV0dXJuIGJveDsKICAgICAgICB9LAogICAgICAgIGdldFNlYXJjaFRyYWNlRGF0YSgpIHsKCiAgICAgICAgICAgIC8vIOi/memHjOS4u+imgeaYr+WIhuS4uuS4ieenjeaVsOaNrgoKICAgICAgICAgICAgLy8gMS4g5LiA56eN5pivIG5vZGUtbGluayDmlbDmja4KICAgICAgICAgICAgLy8gMi7kuIDnp43mmK/mkJzntKLnmoTnu5PmnpwgeyJndCBub3Qgc2VhcmNoIjogW10sICJzZWFyY2gmZ3QiOiBbXSwgInNlYXJjaCBub3QgZ3QiOiBbXX0KCiAgICAgICAgICAgIC8vIGNvbnN0IHJlc3VsdFBvaW50cyA9IFtdOwoKICAgICAgICAgICAgLy8gZm9yIChjb25zdCByZXN1bHRJbmRleCBvZiByZXN1bHRJbmRleGVzKSB7CiAgICAgICAgICAgIC8vICAgICBjb25zdCBjdXJQb2ludCA9IHRoaXMucHJvbXB0UG9pbnRzW3Jlc3VsdEluZGV4XTsKICAgICAgICAgICAgLy8gICAgIHJlc3VsdFBvaW50cy5wdXNoKGN1clBvaW50KTsKICAgICAgICAgICAgLy8gfQoKICAgICAgICAgICAgLy8gRHJhdyB0aGUgc2NhdHRlciBwbG90CiAgICAgICAgICAgIHRoaXMuc2VhcmNoUG9pbnRDYW52YXMuY2xhc3NlZCgnaGlkZGVuJywgZmFsc2UpOwogICAgICAgICAgICB0aGlzLnBvaW50Q2FudmFzLmNsYXNzZWQoJ2ZhZGVkJywgdHJ1ZSk7CiAgICAgICAgICAgIC8vIHRoaXMuc2VhcmNoUG9pbnRSZXN1bHRzID0gcmVzdWx0UG9pbnRzOwogICAgICAgICAgICBQb2ludERyYXdlci5kcmF3U2VhcmNoU2NhdHRlclBsb3QodGhpcyk7CgogICAgICAgIH0sCiAgICAgICAgZ2V0U2VhcmNoQnlJZFJlc3VsdChzZWxlY3RlZE5vZGUpIHsKICAgICAgICAgICAgLy8g6aaW5YWI77yM5oiR5Lus5bqU6K+l6I635Y+W6K+lIGlkIG5vZGUg55qE5pWw5o2u5Z2Q5qCHCiAgICAgICAgICAgIGNvbnNvbGUubG9nKCJwb3MtLS0tLS0tLS0tLSIsIHRoaXMucHJvbXB0UG9pbnRzW3NlbGVjdGVkTm9kZV0pOwoKICAgICAgICAgICAgY29uc3QgZGF0YVggPSB0aGlzLnByb21wdFBvaW50c1tzZWxlY3RlZE5vZGVdLng7CiAgICAgICAgICAgIGNvbnN0IGRhdGFZID0gdGhpcy5wcm9tcHRQb2ludHNbc2VsZWN0ZWROb2RlXS55OwoKICAgICAgICAgICAgLy8gTGV0IHRoZSB3b3JrZXIgdG8gc2VhcmNoIHRoZSBjbG9zZXN0IHBvaW50IGluIGEgcmFkaXVzCiAgICAgICAgICAgIGxldCBncm91cElEID0gLTE7CgogICAgICAgICAgICBpZiAodGhpcy5ncm91cE5hbWVzKSB7CiAgICAgICAgICAgICAgICBpZiAoYWxsVHJ1ZSh0aGlzLnNob3dQb2ludHMpKSB7CiAgICAgICAgICAgICAgICAgICAgZ3JvdXBJRCA9IC0xOwogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBOZWVkIGEgYmV0dGVyIHdheSB0byBzZWFyY2ggc2xpY2VzIG9mIGdyb3VwcyBmb3IgbXVsdGkgZ3JvdXBzCiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNob3dQb2ludHMubGVuZ3RoOyBpKyspIHsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2hvd1BvaW50c1tpXSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBJRCA9IGk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQoKICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IHsKICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICdzdGFydFF1YWR0cmVlU2VhcmNoQnlJZCcsCiAgICAgICAgICAgICAgICBwYXlsb2FkOiB7CiAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IHRoaXMucHJvbXB0UG9pbnRzW3NlbGVjdGVkTm9kZV0sCiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnaWQnCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH07CiAgICAgICAgICAgIHRoaXMudHJlZVdvcmtlci5wb3N0TWVzc2FnZShtZXNzYWdlKTsKICAgICAgICB9LAogICAgICAgIGdldFBvaW50c0RpcygpIHsKCiAgICAgICAgICAgIC8vIOi/memHjOaYr+WQpuaJp+ihjOivpeWHveaVsO+8ge+8ge+8gQogICAgICAgICAgICBjb25zb2xlLmxvZygi5piv5ZCm5omn6KGM6K+l5Ye95pWw77yB77yB77yBICAgZGlzIiwgdGhpcy5wcm9tcHRQb2ludHMpCgogICAgICAgICAgICBjb25zdCBwYWlyUG9pbnRzID0gWzk2NTI1LCAxMDg3OTEsIDE2NjUxOCwgMjY3MTc2LCAzMzEwMywgMTY1NTQ5LCAyMDMxOTMsIDI5MDcyNSwgMjU3MzEsIDExMzU3MiwgMTQxMTgxLCAyMDQzNzYsIDI4NDk5NywgMjIyNTI0LCAxMjgzMjQsIDE1NjIzMSwgMjA1NDc4LCA2NTI3NSwgOTI2OTMsIDI2MDksIDE4NTE3LCAzOTIxOSwgMjkwNTM1LCAxNTM4OTcsIDIzNDUwMSwgMjMwMDY0LCAxMzI3MDYsIDIzMjUzNCwgMjAxMDYsIDUxMzY5LCAxODE5NzEsIDI3OTU0NiwgMTY5MzEzLCAxMjk0NTUsIDEwMzg3MiwgMTc3NjQxLCA1Mzc5MCwgODIwODAsIDExOTUwLCAyODU3NzcsIDEyMDM0MSwgMjEwNDI4LCAxMDM0ODEsIDI2NDQxMywgMTEzMDU2LCAxNTI3MTksIDQ1NjIxLCAxODA1NTgsIDE3NjkyOCwgMjUwNzIzLCAxMTY2MjIsIDEyODQ1OCwgMzY5MjQsIDE2ODE3LCAyNTk0MzgsIDI3OTA2MiwgNTEzOTYsIDEwMTY2NiwgMzM1NjEsIDI1ODc3NywgMTU3NTQ4LCAxNDI4MjYsIDE2OTg2MiwgMTYwNzE2LCAyMDk3MTYsIDEwMTA0MCwgMTgzMDYzLCAxMDc2MzksIDE0ODY5LCAxMTQ0NzksIDExODY5MywgMTU0MDQ3LCAyMDA1MzQsIDYwNTI1LCAyNjM4NDMsIDE4NTM4MywgODIzMjksIDQxOTAzLCAyNTI1NDEsIDI4NjQzMSwgMjY1MjkyLCAxNTMxNTAsIDM5NDMyLCAyNzYwODUsIDEyMDgxOSwgMTQyMjEwLCA5ODU1MywgNjQ0MzksIDI1Njg0NCwgNzEzNzAsIDIyNDI3LCA0OTU5MiwgMjI4MTgyLCAxMjAzMzksIDI5MTUzLCAyMzA5NDYsIDI5OTYzMCwgMTE2NTU4LCAyNTAyOTksIDEyNTkwOSwgMjE2NjYxLCAyODg4MTMsIDQ4MDAzLCAxMTcyMDQsIDE5MjkwOSwgMTg3MjAyLCAyMTUxMjksIDI3MzI0MSwgMTM4ODA3LCAxOTY2NjEsIDI2ODc1LCA3OTc1MCwgMTA0ODY2LCA0NTY5NSwgMjA0NDMxLCAyMzE1NzMsIDc2MjE2LCAxMDIyNTMsIDEyNTYzNCwgMjUxODI3LCAyNDczODIsIDgxMTU2LCA1Nzc5OCwgMzQxOTQsIDg3NjQ3LCAxODY4NDAsIDc5ODQ0LCAyOTUzMjYsIDI1NjM5NiwgMzIwODAsIDEwNTM0LCAyMDA1MDUsIDI3MzkyMiwgMzM1NzQsIDgxMjUsIDgzNjYsIDI5MTEzNywgMTQ1OTUyLCA5ODgyOSwgMzk2MDAsIDI0MjQwNywgMTAxMjk1LCAyMzg3MjcsIDE4NTkyNiwgMjAxNzk3LCA2Mjc2OSwgMTgyMTY3LCAyMjUyNTUsIDI2OTE0MiwgNTA0OCwgMTc5ODQsIDI2MDMyOCwgMTA4MTk3LCA2NzYwMiwgMjc4OSwgMjkxMzI5LCAzNjQ1MiwgMTU4MDAzLCAxODEyOTgsIDE5NDQ3OCwgMjA4NzA3LCA0NzEyNywgMjIzNjIyLCAyMDA0NTQsIDIyNjA5MiwgMzQ0NCwgMjI3OTE5LCAxMjU4MTUsIDk2OTMyLCAxMjQzNjYsIDQxMDY3LCAyNDA3NjUsIDEwOTgxNywgMjY3NTMyLCAxNDMzODEsIDIwMDQ1NSwgMjEzMjIwLCA2NDI3OSwgMTM1MzEyLCAyMTIyNzcsIDg5NjE0LCAxOTQzNiwgMjY2NjEzLCA1NjkwNiwgNjM1NSwgMTU1MTU1LCAxMjI1NTEsIDI4Mzg3OCwgMTU4NDMsIDE4OTIwMiwgMjkzNTI1LCA3MTU0NCwgNjExNTgsIDEyNjQ2MywgMTEzNTQ3LCAyMzAwNjMsIDU4NTE3LCAyMjUzMzMsIDE0ODU1NiwgMjQzNjYyLCAyMjg4MzUsIDE2OTIxLCAyNDE0ODEsIDI3MDc1OSwgMjM5MzU0LCAyMjMwNTgsIDI5ODk2MywgMTg3MzksIDI5NTMzMCwgMTg2ODYwLCAzODM4MSwgMTYyMjYyLCAyMDc4MjYsIDIzODE5OCwgNTU0MDIsIDkyMzI3LCAyNTM3NDksIDYyMDU0LCAyMjk0OTIsIDIwOTY1LCAyODA2NDksIDQ0MDcxLCA0Nzg1MywgMTkyMjc3LCAxNjE2NzQsIDU4MTEzLCAxODY1OSwgMTI2NDY5LCAyNjk0NDAsIDE3OTU3MywgMjczNDI1LCAxNTAzMjIsIDQ2MTg0LCAxNTkzMDgsIDkyNTM1LCAxOTE5NjQsIDI2OTE4OCwgMTA4NzA4LCAxNzI2MDcsIDQxOTE2LCAxOTQyMTcsIDI0Mjg4MSwgMjA4MTAyLCAxNTQzODEsIDIwNjY3LCAyNzgyMywgMjkwODYsIDI3NjA3NCwgMTE2MDEsIDU0OTI4LCAxNDIyLCAxODM1NjksIDE1Nzk3MiwgMTg0NTM5LCAxMjI1MTYsIDExMzM1NywgNzkzMTQsIDI2MjI2MywgNTQyMDgsIDI3NzMxNCwgMjQzOTk3LCA5MDEzNywgMjc1NjE0LCAxNjcxMiwgMTI1NDg4LCAxNjU1NjcsIDI3MjI0LCAyNTE3NzUsIDExMDQ1MiwgMjA0NTEsIDEwNTMxNSwgMTM2MjgwLCA4ODk1NiwgMTc1NjQ0LCAxMjE1NjUsIDIxNzA1OSwgMTY4Mjg1LCAyNDc3NzksIDE4NTMzMywgMjM3OTY4LCA0NjQxLCAyMzI5OSwgMTM4NDA1LCAyNzIzMjEsIDg3MjI0LCAxNDI1MTQsIDkwNjk1LCAxNTAxNzYsIDEyNDg0NSwgMjE2Njc4LCAyOTk1MDYsIDIxMTUyOSwgNDYzNSwgMjEzNjU3LCA2NTQyNCwgMTMxNjI5LCAyMDQxOCwgMjMwMzk3LCA4MjkzMywgMjg1MDk3LCAxODY1OTYsIDIxODgzNCwgMjYyMTk3LCAxMDk1NjcsIDI0OTcxMiwgMTU5OTMxLCAyMjg2MTYsIDExMTEwOCwgMjQ2NjgyLCA1MjQ3OCwgNTc5NTcsIDc3Nzk5LCAxODY2MDAsIDcwNzg5LCAxODQ1MjksIDIwNDQyMywgMjE3MzQ3LCAxMTM3OTQsIDI3NDUzMCwgMTA5MTQ4LCA4Njc1NSwgMjkxNjQ5LCA1OTQ3NiwgMTA1MzA3LCA2NDgxMCwgMjA3OTQ5LCA3MDMzNSwgNTk4NzcsIDIyODI4MiwgMTUwMjUzLCAxMzAyOTEsIDExMjY2MCwgNTMyODEsIDE3MTk2NiwgMTg2OTMyLCA1OTQxNywgMTU3NTgzLCA4MzQ4NSwgMTg1MjE5LCAzMzMyMywgNTA0ODAsIDE1NzE0OCwgMTEwNTMyLCAxNTQxNTAsIDI4ODQ0MCwgMTg2MzQ3LCAyMjQ2OTgsIDc3NjI0LCAyMjc0ODIsIDIxNDcxOSwgNjYxNjYsIDk1MzQwLCA2MDA2MywgMjQ4OTcwLCAxMzM3MTksIDIwNzY1MiwgMzE1OTYsIDI4NTYyMywgMjA5MjQ4LCAxNjQzMDEsIDQwMjEyLCAxNDQ5NzgsIDI0MDA5LCAyNzI0OTQsIDI1MzczMSwgMTM3OTcsIDIzNjMzNywgOTM3NTgsIDk4ODA2LCAxMzU4NzAsIDI0NDI2MSwgMjQwOTQ3LCAxNDA0ODAsIDI5NjUyMywgMjMxMjcwLCA1NTEzOSwgMjEwNjE3LCAyODYyNTIsIDI1MTE2MCwgMTA0NDczLCAyNjk5MTQsIDQwMTc4LCAxNjAzMzgsIDE2OTIxNywgNTEyMDksIDE1OTc1NSwgMjczMDEsIDE2NDAzNSwgMjAyMzY0LCAxMzUwODgsIDIzMTA0MiwgMTE2NTI4LCA1OTM0NCwgMTI1NDc0LCAxODEyMzQsIDkyMTE2LCAyODE2MSwgMTcyNTQwLCAyMTI4NjEsIDEwMTQxMSwgMjQ3OTUsIDkzNDQ1LCA3OTAxLCA0MDMxMiwgMjY2MTM5LCAxMTg3NjcsIDQwODM0LCAzMTQyLCAxNjY2NDAsIDI0NDg3NCwgMjMwNzU0LCAyNjk0ODksIDI5NjgyMiwgMjkyMjAxLCAxMjYzNDcsIDEwNjM0LCAyMDE4NjMsIDIzMjM5MiwgMjcyNDc0LCA1NzYwOSwgNTQ2MDksIDE4MzgwMiwgMjUwOTU0LCAyMzg4OCwgMTU3ODYxLCAxNzc3MDUsIDIxNDUzMSwgNzAzMjEsIDE3NjA5MiwgMjQ5NDUyLCA1NTA5MiwgNjg3NTYsIDI3MDUzNSwgMTQ5ODY2LCAxMDY4NjEsIDUxMzUwLCAyNjk4ODcsIDEwNTA3MCwgODMxNTksIDEyMDc4OSwgMjUwMzg2LCA2OTMzOSwgMjE4NTM3LCAxNzkzMzIsIDIyMTM2MSwgMjcwNDE5LCA4NDE4LCAyODAwNjUsIDM2ODgyLCAxMTcxMDcsIDI5Mjc0NywgMTQ1MjE4LCAxMDg5MDQsIDE3MTI5OSwgMTE5ODk2LCAyOTgyMjUsIDIwNDY5OSwgMTIxOTc2LCAyMDkyODMsIDQxNTE4LCAyNjM3MTAsIDIyNTU2OCwgMjYxMDQyLCA5OTQzNSwgNTYxMjcsIDg0MDc5LCAyNzkzNzcsIDE0MDQyOCwgMjE0MDA3LCAxNDY4MjYsIDI2MjA0OCwgMjc5NDE5LCAyOTc0NTYsIDIyMzg2MiwgNjgwOTcsIDI4NjY0NCwgMjczODEsIDU0NTUwLCA0NjYwNywgMTQwMTc5LCA4ODc0NywgMjAxODkxLCAzMDQzNCwgMTI4MjI2LCAyMTIzMzAsIDIyMDcyMywgMTgwMzQ2LCAyOTY4MTgsIDg2NzQ5LCAxNzM2OTEsIDE5NTY1NywgMTYxNjc0LCA4MjgzNSwgMjkzMTk2LCAxODQxOTUsIDI0MTM5NSwgNzI5NDMsIDUxMjYyLCAyOTU5NTMsIDE3MDQzOSwgMTM5NjI4LCAyMDMwNjgsIDU0OTQzLCAyNjczOTYsIDM5MjkwLCA2NjcwNiwgMTQwOTg5LCAyNjY0ODYsIDIwMTM3NCwgMTc0MTUyLCA5OTQ0OCwgNjc3NzksIDY4MDI3LCAxODYwNSwgMjcyODUzLCAyOTU3MDgsIDE5MTE4MSwgMjE4Mzg3LCA3Mzc0MiwgMjk4NDQsIDIxMTQ5LCAyODMxMjMsIDE0MjY4NCwgMjM1ODcyLCAxMDc0MzksIDU1OTU3LCAyMDg3NTgsIDE3MDY5NywgMTcwNDQ0LCAyNzg5ODksIDEyODE3OCwgMTE3MjQxLCAyMjM4OTksIDIxMjgzNCwgOTA4NjksIDE1MzcxLCAyMjQ5MTgsIDEwNzE3OSwgMjQyMDUxLCAxMzEyOTksIDE3NjQ1NCwgMTgwMTg4LCAxOTYzOTMsIDI3NjIzMSwgMzkyMDIsIDIwMjc3OCwgMjY4NzQ5LCAyMDkxNzMsIDI3NTIxNCwgOTE5OTIsIDE3MDI2MSwgMTAzNzcyLCAxNDIxMDUsIDE2NDQzNSwgMjg5MjUzLCA0NTU0LCAyMzgwNTYsIDI0OTk1NSwgMTM1NDksIDk5NjEwLCAxOTM0MTksIDIyMDk3MywgMTEwMTk5LCAxNzg1OCwgMTQ5MTAwLCAyMjg0MDQsIDEzMzc2OCwgMTkzODY2LCAxNzI1MDQsIDEzNjA3MCwgMTcwODY1LCAyMTg0ODcsIDE4MTAyLCAyNjU0MTgsIDU0MDI4LCA0NjIyMywgNjUyNjksIDExNzE5MiwgMjcxMDE1LCA0MzczMiwgMjA4OTI3LCA3MjI2MCwgNTc0NzIsIDEzOTk4MywgNDc1MzUsIDE0MjA5OCwgMjMzMTUyLCAxNTgyMTksIDE1Njc2NCwgMjk2NjI4LCAyNTk4NjcsIDE1ODEyLCAyMjcyMjMsIDE0ODA5NiwgMTg0MDgyLCAyODU3MDcsIDE3NTc5MCwgMTE3OTc0LCAxMjU1MTAsIDIzMTQwNywgMjI1OTI5LCAyNTk0NjAsIDE0ODM3OSwgMTI0NTIsIDEwMDk5MywgMjcyNTI3LCAzNTE4NiwgMTM3NTY2LCA0MDY1MiwgMjA0OTQzLCAyMTIzMDYsIDI2MjAxMSwgMTc3NDA1LCA4MTkyMywgMjE4NzA3LCAyNTE5NjYsIDEzMzAyNiwgMTA4MjcxLCAyNDY5NywgMjk5MTk1LCAxNjcwMjUsIDIwOTkzMywgMjM3NDE2LCA4MzM0OCwgMTg4OTE5LCA0ODE2MiwgNjM4NDEsIDEzMDIzMCwgMTEzMTQwLCAxMjAxNCwgMTI2ODQ3LCAyMjcwOTUsIDE2Nzg4MywgMjEzNTE5LCA5MDU1MywgMjczOTExLCA5MTAwMiwgODE4MzcsIDYyMzI1LCAxOTMzNjksIDE3NTU4NiwgMzAxOTIsIDQyMDk0LCAxMTEzOTksIDEzMDg3MywgMTgxMTE2LCAyNzQ1MzQsIDIxMDA3OSwgMTM1MzMyLCAxNDI1MzgsIDIyMzMzLCAyMDk5MTgsIDE1MTgzNiwgODQyMiwgMTQ3MjM2LCAzODIyOCwgMTMzOTgyLCAxOTg3NTksIDI0Mjk3MSwgOTY0MzcsIDEyMzk2MywgMjIyNzE2LCAyODM3MSwgMjUxMjQzLCAxNDAwNiwgNDM2NjUsIDI4MDk4MSwgMTkwNjcsIDI0NzcwNCwgMTYxODM5LCAxMDM1MzAsIDgyNjIyLCAyNjE0MzMsIDI2NDYwMywgNzc2MjMsIDE0MjUwOSwgNTA3MTYsIDM0Mjk4LCA3Njk4MywgMTYzNzcsIDI5MzE4OCwgMjc0MjE2LCAxNjk4NTIsIDI0NTU4OCwgMTY4MDg5LCA0NzEyMywgNDY3MzQsIDQzNjY1LCAxOTMxMzgsIDIyMjY1OCwgMTE5NTEyLCAyMzQ5NzYsIDIzMzMxLCAxNTU5NTAsIDE4MzA0MiwgMTAxODUyLCAyNjYwNTAsIDE4MjI1NywgMTk4ODYsIDEyODgxOCwgMjQ3MTI3LCA0MzY0NiwgNzgyLCA5MDQ4NywgMjE2NDc0LCAyNjkwOTMsIDg2MDM1LCAxNjk2NzAsIDI1MDA0MiwgMjcxOTA0LCAyMzE5MjksIDg4NTcyLCAyNDkzNDIsIDEwNTkyOCwgNzIyMTEsIDEzNDU1MiwgMTk1MDM4LCA1ODk3MywgMjY5MzYwLCA1NjU5MywgMTUxNzIwLCAxODQ5MDMsIDI3MjQ0MiwgMjI0NTk5LCAyNzIzMjcsIDU2NTcsIDE2MzI1OSwgMTE4ODkwLCAxMjQ1NjksIDE4MTY2OSwgMTQzNTA4LCAyMjU0MDAsIDI2Mzg1LCAzMDk3OSwgODcxMzUsIDg3MDMzLCAxNzUwNDEsIDYyMDE5LCAxNTI1NDgsIDE0MjQ0LCA2NDYyMSwgMjQxOTM3LCAyNTExNzQsIDI3NTg3MiwgMTYyNTAzLCAzMTg2NywgMTMxODgzLCA1NjI4MSwgMjIwNTgwLCAxNDk2MDIsIDg5MzQ5LCAyODI1MjMsIDE4MjE4OCwgMTAxMDA3LCAyNTM2NjIsIDIwOTA0OSwgOTU5NzcsIDIzMDQzNywgMTA4MzgyLCAxNzA3NjksIDE0NjQ0MiwgNzk3NjEsIDIyMzY4NywgMjk1NjUzLCAxNjA4MzIsIDE3OTY2MSwgMTkyOTYyLCAxNjE3OTMsIDg1MjkxLCA0MDAxMCwgMjYzMzk0LCAyNjc2MCwgMjg4MTQsIDI3MjM2MywgMTY0OTA3LCAxNzgxNzIsIDE0NzgzNCwgNzcxOTQsIDE2MjQzNCwgMTIwNTgzLCA0NjIzNywgMTM4NDIwLCA1ODY4OCwgMTA2Njg1LCAxMTc5NDUsIDE5MTMyOCwgMjg1OTM0LCAyNzcwMzMsIDM4NTkxLCAxMzEyMTksIDIxNTg2MiwgMTczODY1LCAyNjQ5NzEsIDU5ODYsIDExMDY1MSwgODY2MTYsIDI0NDUxMCwgMTU1OTgsIDEzNDM2OCwgMjM3OTY0LCAyMDU1NDgsIDE5MDgzMywgNTgwNDUsIDIwMTUxMSwgMjQ0Mzg3LCA5NjMwNiwgNDM1NzksIDI4MDM0NywgMjk3MTkwLCAxMDE1NSwgMjg1Njg3LCAxMjQ3MDYsIDI3MzAxNywgNTQwODUsIDM1Nzk2LCA2NTc2NiwgMjUwNTk3LCAxOTI4MjcsIDIzNTQ1MCwgNTkwNjUsIDE0NzQ0OCwgMTg0MzIzLCA2NTM0OCwgMTExMTkwLCAyNjc3ODUsIDIwMDM1NSwgNjc1NDgsIDI5MTE1LCAxNDE2NjUsIDc2NDYsIDQ3NzY3LCAxODE5NjIsIDEyNzcwLCA0NDgyMSwgMTAwOCwgMTM4NTQ3LCA1Mjk3NiwgODQzNjAsIDE1OTkwMywgMjgwNDAxLCA0MjczNCwgNTgwMDcsIDIyMDM2MywgMjA1NzIyLCAxMDI0ODIsIDQxNDM3LCA1Mjc1OCwgMTExNDA1LCAxMTk3NTIsIDE4NDQyNywgNDY4NzQsIDQyMjU0LCAxMjg5NzMsIDEwOTY4MSwgMzIxMDAsIDE4Mjg5MSwgMTE1NjE0LCA5NzQ1NiwgMjI1NDMwLCA5OTI0MSwgMTc2MTAwLCAxNDcwODUsIDExNjQwOSwgODU2MjYsIDE4MjA2NiwgMTI1ODMwLCAyMjcwNzAsIDQyMDQyLCAxMzkwMzYsIDE3Mzg0MSwgMTA0NTc2LCAxNjcyOCwgMjk3NjU5LCAxMzc3ODUsIDE4OTM2OCwgMjMzNjYzLCA1NTM4LCA5MjM0NywgMTUwMDAwLCAxODE3NzMsIDQ0MDM5LCAyNDUyNzgsIDI2MTIxMSwgMTUyNTkyLCA0NDgxMSwgMTMyMjM3LCA0OTc2NywgMjIyNjk1LCA2OTA3MCwgMTczMTQ2LCAxNDI3ODAsIDQxOTU1LCAxOTEzOTUsIDIxMDQwNCwgMjkwMTgzLCA4NTYyLCAxNzIzNTAsIDIzNDE5NSwgMjU4NjA5LCAxNDY5MTMsIDE5NjE0NiwgMjQ0NDgxLCAxNjkzNzgsIDIyNDM4NSwgMTkzMTM4LCAxNDkyMTksIDEyODExMSwgMTI2MDcsIDI1MTA4OSwgMjM2NDcxLCA2Njg3NCwgMTA5MDcyLCAxNzUwMTAsIDE5ODYwNCwgMjQ4MDUxLCAxNTg2MTIsIDE4OTQ0NSwgMjUwNDI4LCAyMjU5NTAsIDE2OTkyMywgMTk1MzExLCA3NTU3OSwgMjgyODMwLCAyNDU0NjksIDQ4ODMsIDQ0ODc3LCA5NTkwNiwgNzc1NzcsIDI1NTkyMiwgMTkzMTM5LCAxODExODcsIDYwMTIwLCAyNzkxNjgsIDE4ODE2NSwgMjUyODM0LCAxNjUxODgsIDI0Mjc0OCwgMjMyMSwgMTMxNDcxLCAxMjA4NTIsIDI1NDcxMiwgMjc0MzAsIDI2NTk4OCwgMjE0ODMxLCAxMzA4NSwgMTI1OTM4LCAyOTMxOTYsIDIzMjYwMCwgMTcwMzc3LCAzNTI4OCwgMTk5MTkzLCAxODUzMzAsIDIwMjY0NiwgMjk0MzEsIDM4NTYsIDE2OTM2OCwgMTMyOTY0LCAyNjU0MzksIDI0MjA0MiwgMjA0NTA1LCAxNTY4OSwgNTA5MzUsIDIyOTMxNSwgMTM3NTIsIDE5MzM5LCAyMDY2NTYsIDE2NjczMiwgMTk5MTc2LCAyNzcwMTYsIDE3NDA2MywgMTUwMDc1LCAxMjY1NDQsIDc1MTUzLCAyMzg0NDcsIDI3MTAwLCA1MDc0MCwgMjM0NDg3LCA2NTA0MCwgMTU5ODAwLCAyODc2MiwgMjEwMzA1LCAzMzk4NywgODg4NSwgMTU3OTkzLCAyMTA0ODUsIDE0NDc3NSwgMTM4ODAyLCAxNTc3MDgsIDYzNDQzLCAyMjUzOTUsIDg5MDE1LCAyNzk1MTIsIDE3OTg5OCwgNTEyNzIsIDM3OTM4LCAxNDM3OTksIDQyOTMyLCA4OTQ1MCwgMjQ2NzEsIDI2MzcyNV07CgogICAgICAgICAgICAvLyDovpPlh7rnlJ/miJDnmoTpmo/mnLrmlbDlrZcKICAgICAgICAgICAgY29uc29sZS5sb2cocGFpclBvaW50cyk7CgogICAgICAgICAgICBsZXQgZGlzX2xpc3QgPSBbXTsKCiAgICAgICAgICAgIC8vIOiOt+WPluefqemYtQogICAgICAgICAgICBjb25zdCB7IGRhdGFTY2FsZU1hdHJpeCwgbm9ybWFsaXplTWF0cml4IH0gPSB0aGlzLndlYkdMTWF0cmljZXM7CgogICAgICAgICAgICAKICAgICAgICAgICAgLy8g5a6a5LmJ5LiA5Liq5Ye95pWw5p2l5bqU55So55+p6Zi15Y+Y5o2iCiAgICAgICAgICAgIGZ1bmN0aW9uIGFwcGx5TWF0cml4KG1hdHJpeCwgcG9pbnQpIHsKICAgICAgICAgICAgICAgIGNvbnN0IHggPSBwb2ludC54OwogICAgICAgICAgICAgICAgY29uc3QgeSA9IHBvaW50Lnk7CiAgICAgICAgICAgICAgICBjb25zdCB3ID0gMTsgLy8g6b2Q5qyh5Z2Q5qCHCgogICAgICAgICAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgICAgICAgICB4OiBtYXRyaXhbMF1bMF0gKiB4ICsgbWF0cml4WzBdWzFdICogeSArIG1hdHJpeFswXVsyXSAqIHcsCiAgICAgICAgICAgICAgICAgICAgeTogbWF0cml4WzFdWzBdICogeCArIG1hdHJpeFsxXVsxXSAqIHkgKyBtYXRyaXhbMV1bMl0gKiB3LAogICAgICAgICAgICAgICAgICAgIHc6IG1hdHJpeFsyXVswXSAqIHggKyBtYXRyaXhbMl1bMV0gKiB5ICsgbWF0cml4WzJdWzJdICogdwogICAgICAgICAgICAgICAgfTsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgZm9yIChjb25zdCBwYWlyIG9mIHBhaXJQb2ludHMpIHsKICAgICAgICAgICAgICAgIC8vIOiOt+WPluWOn+Wni+WdkOaghwogICAgICAgICAgICAgICAgY29uc3Qgc3RhcnROb2RlID0ge3g6dGhpcy5wcm9tcHRQb2ludHNbcGFpcl0ueCwgeTogdGhpcy5wcm9tcHRQb2ludHNbcGFpcl0ueX07CiAgICAgICAgICAgICAgICBjb25zdCBlbmROb2RlID0ge3g6dGhpcy5wcm9tcHRQb2ludHNbcGFpciArIDMwMDAwMF0ueCwgeTogdGhpcy5wcm9tcHRQb2ludHNbcGFpciArIDMwMDAwMF0ueX07CiAgICAgICAgICAgICAgICAvLyDovazmjaLkuLrlg4/ntKDlnZDmoIcKICAgICAgICAgICAgICAgIC8vIOWFiOW6lOeUqOaVsOaNrue8qeaUvuefqemYtQogICAgICAgICAgICAgICAgLy8gY29uc3Qgc3RhZ2VQb2ludCA9IGFwcGx5TWF0cml4KGRhdGFTY2FsZU1hdHJpeCwgc3RhcnROb2RlKTsKICAgICAgICAgICAgICAgIC8vIGNvbnN0IHBpeGVsUG9pbnQgPSBhcHBseU1hdHJpeChub3JtYWxpemVNYXRyaXgsIHN0YWdlUG9pbnQpOwoKICAgICAgICAgICAgICAgIC8vIGNvbnN0IHN0YWdlUG9pbnRfZW5kID0gYXBwbHlNYXRyaXgoZGF0YVNjYWxlTWF0cml4LCBlbmROb2RlKTsKICAgICAgICAgICAgICAgIC8vIGNvbnN0IHBpeGVsUG9pbnRfZW5kID0gYXBwbHlNYXRyaXgobm9ybWFsaXplTWF0cml4LCBzdGFnZVBvaW50X2VuZCk7CgogICAgICAgICAgICAgICAgY29uc3QgeDAgPSB0aGlzLnhTY2FsZShzdGFydE5vZGUueCk7CiAgICAgICAgICAgICAgICBjb25zdCB5MCA9IHRoaXMueVNjYWxlKHN0YXJ0Tm9kZS55KTsKCiAgICAgICAgICAgICAgICBjb25zdCB4MSA9IHRoaXMueFNjYWxlKGVuZE5vZGUueCk7CiAgICAgICAgICAgICAgICBjb25zdCB5MSA9IHRoaXMueVNjYWxlKGVuZE5vZGUueSk7CgoKICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCJlbmROb2RlIiwgZW5kTm9kZSk7CgogICAgICAgICAgICAgICAgY29uc3QgZGlzID0gTWF0aC5zcXJ0KE1hdGgucG93KHgwIC0geDEsIDIpICsgTWF0aC5wb3coeTAgLSB5MSwgMikpOwoKICAgICAgICAgICAgICAgIGRpc19saXN0LnB1c2goZGlzKTsKCiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIC8vIOWvuSBkaXNfbGlzdCDmsYLlubPlnYflubbov5vooYzovpPlh7oKICAgICAgICAgICAgLy8g5a+5IGRpc19saXN0IOaxguW5s+Wdh+W5tui/m+ihjOi+k+WHugogICAgICAgICAgICBjb25zdCBhdmVyYWdlRGlzID0gZGlzX2xpc3QucmVkdWNlKChzdW0sIHZhbHVlKSA9PiBzdW0gKyB2YWx1ZSwgMCkgLyBkaXNfbGlzdC5sZW5ndGg7CgogICAgICAgICAgICBjb25zb2xlLmxvZygiZGlzX2xpc3QiLCBkaXNfbGlzdCk7CiAgICAgICAgICAgIGNvbnNvbGUubG9nKCJBdmVyYWdlIGRpc3RhbmNlOiIsIGF2ZXJhZ2VEaXMpOwoKICAgICAgICB9CgogICAgfSwKICAgIGNvbXB1dGVkOiB7CiAgICAgICAgLi4ubWFwU3RhdGUoewogICAgICAgICAgICBpY29uU2hvdzogImljb25TaG93IiwKICAgICAgICAgICAgZGF0YU5vZGVMaW5rOiAiZGF0YU5vZGVMaW5rIiwKICAgICAgICAgICAgc2VsZWN0ZWROb2RlOiAic2VsZWN0ZWROb2RlIiwKICAgICAgICAgICAgdGFibGVGaXRlclJlc3VsdHM6ICJ0YWJsZUZpdGVyUmVzdWx0cyIKICAgICAgICB9KSwKICAgIH0sCiAgICB3YXRjaDogewogICAgICAgIGljb25TaG93OiB7CiAgICAgICAgICAgIGhhbmRsZXIobmV3VmFsLCBvbGRWYWwpIHsKICAgICAgICAgICAgICAgIHRoaXMuc2hvd0dyaWQgPSBuZXdWYWwuZ3JpZDsKICAgICAgICAgICAgICAgIHRoaXMudG9waWNDYW52YXNlcy5mb3JFYWNoKGMgPT4gewogICAgICAgICAgICAgICAgICAgIGMuY2xhc3NlZCgnaGlkZGVuJywgIXRoaXMuc2hvd0dyaWQpOwogICAgICAgICAgICAgICAgfSk7CgogICAgICAgICAgICAgICAgdGhpcy5zaG93VHJhY2UgPSBuZXdWYWwudHJhY2U7CiAgICAgICAgICAgICAgICB0aGlzLnNlYXJjaFBvaW50Q2FudmFzLmNsYXNzZWQoJ2hpZGRlbicsICF0aGlzLnNob3dUcmFjZSk7CiAgICAgICAgICAgICAgICB0aGlzLnBvaW50Q2FudmFzLmNsYXNzZWQoJ2ZhZGVkJywgdGhpcy5zaG93VHJhY2UpOwoKICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCJzaG93IiwgbmV3VmFsLCBvbGRWYWwpCgogICAgICAgICAgICAgICAgaWYgKG5ld1ZhbC5wb2ludHMgIT09IHRoaXMuc2hvd1BvaW50c19iYWNrKSB7CiAgICAgICAgICAgICAgICAgICAgLy8g5L2/55SoIG1hcCDlj5blj43miYDmnInlgLwKICAgICAgICAgICAgICAgICAgICB0aGlzLnNob3dQb2ludHMgPSB0aGlzLnNob3dQb2ludHMubWFwKHBvaW50ID0+ICFwb2ludCk7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb2ludENhbnZhcwogICAgICAgICAgICAgICAgICAgICAgICAuY2xhc3NlZCgnaGlkZGVuJywgIW5ld1ZhbC5wb2ludHMpCiAgICAgICAgICAgICAgICAgICAgICAgIC5jbGFzc2VkKCdmYWRlZCcsIG5ld1ZhbC5wb2ludHMpOwogICAgICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoUG9pbnRDYW52YXMuY2xhc3NlZCgnaGlkZGVuJywgbmV3VmFsLnBvaW50cyk7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG93UG9pbnRzX2JhY2sgPSAhdGhpcy5zaG93UG9pbnRzX2JhY2s7CgogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9LAogICAgICAgICAgICBkZWVwOiB0cnVlLAogICAgICAgIH0sCiAgICAgICAgZGF0YU5vZGVMaW5rKG5ld1ZhbCwgb2xkVmFsKSB7CiAgICAgICAgICAgIGlmIChuZXdWYWwgIT0gb2xkVmFsKSB7CiAgICAgICAgICAgICAgICB0aGlzLmdldFNlYXJjaFRyYWNlRGF0YSgpOwogICAgICAgICAgICB9CiAgICAgICAgfSwKICAgICAgICBzZWxlY3RlZE5vZGUobmV3VmFsLCBvbGRWYWwpIHsKICAgICAgICAgICAgaWYgKG5ld1ZhbCAhPT0gb2xkVmFsICYgbmV3VmFsICE9PSAnLTEnKSB7CiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygi5a+56L+Z5Liq6L+b6KGM6L6T5Ye6IiwgdHlwZW9mIG5ld1ZhbCkKICAgICAgICAgICAgICAgIHRoaXMuZ2V0U2VhcmNoQnlJZFJlc3VsdChuZXdWYWwpOwoKICAgICAgICAgICAgfQoKCiAgICAgICAgfSwKICAgICAgICB0YWJsZUZpdGVyUmVzdWx0cyhuZXdWYWwpIHsKCiAgICAgICAgICAgIGlmIChuZXdWYWwubGVuZ3RoID4gMCkgewoKICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdExpc3QgPSBbXQoKICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcmVzdWx0SW5kZXggb2YgbmV3VmFsKSB7CiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VyUG9pbnQgPSB0aGlzLnByb21wdFBvaW50c1tyZXN1bHRJbmRleF07CiAgICAgICAgICAgICAgICAgICAgcmVzdWx0TGlzdC5wdXNoKGN1clBvaW50KTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoUG9pbnRSZXN1bHRzMiA9IHJlc3VsdExpc3Q7CiAgICAgICAgICAgICAgICB0aGlzLnNlYXJjaFBvaW50Q2FudmFzLmNsYXNzZWQoJ2hpZGRlbicsIGZhbHNlKTsKICAgICAgICAgICAgICAgIHRoaXMucG9pbnRDYW52YXMuY2xhc3NlZCgnZmFkZWQnLCB0cnVlKTsKCiAgICAgICAgICAgICAgICBQb2ludERyYXdlci5kcmF3U2VhcmNoU2NhdHRlclBsb3QyKHRoaXMpOwoKCiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICB9Cn07CgoK"},{"version":3,"sources":["DistributionView.vue"],"names":[],"mappings":";AAqBA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;;;AAGA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;;AAGA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA","file":"DistributionView.vue","sourceRoot":"src/views/MainView/MiddleMainView","sourcesContent":["<template>\n    <div class=\"mapview-class\">\n        <div id=\"popper-tooltip-top\" class=\"popper-tooltip hidden\" role=\"tooltip\">\n            <span class=\"popper-content\"></span>\n            <div class=\"popper-arrow\"></div>\n        </div>\n\n        <div id=\"popper-tooltip-bottom\" class=\"popper-tooltip hidden\" role=\"tooltip\">\n            <span class=\"popper-content\"></span>\n            <div class=\"popper-arrow\"></div>\n        </div>\n\n        <div class=\"distribution-main\" ref=\"distributionMain\">\n        </div>\n\n    </div>\n\n</template>\n\n\n<script>\nimport { mapState } from \"vuex\";\nimport { config } from '@/config/config';\nimport createRegl from 'regl';\nimport d3 from '../../../utils/d3-import';\nimport { anyTrue, allTrue } from '../../../components/Embedding/Embedding';\n\nimport LoaderWorker from '../../../components/Embedding/workers/loader.worker.js';\nimport TreeWorker from '../../../components/Embedding/workers/tree.worker.js';\nimport SeacherWorker from '../../../components/Embedding/workers/search.worker.js';\n\nimport * as Embedder from '../../../components/Embedding/Embedding';\nimport * as PointDrawer from '../../../components/Embedding/EmbeddingPointWebGL';\nimport * as Labeler from '../../../components/Embedding/EmbeddingLabel';\nimport { HOVER_RADIUS } from '../../../utils/utils';\n\nexport default {\n    name: \"DistributionView\",\n    components: {\n\n    },\n    data() {\n        return {\n            component: null,\n\n            svg: null,\n            svgFullSize: { width: 0, height: 0 },\n            svgSize: { width: 0, height: 0 },\n            svgPadding: { top: 0, bottom: 0, left: 0, right: 0 },\n\n            topSvg: null,\n            topicCanvases: [],\n\n            // points\n            pointCanvas: null,\n            pointRegl: null,\n            frontPositionBuffer: null,\n            frontTextureCoordinateBuffer: null,\n            frontBufferPointSize: 0,\n\n            // search trace\n            searchPointCanvas: null,\n            searchPointRegl: null,\n            searchPointPositionBuffer: null,\n            searchPointTextureCoordinateBuffer: null,\n            searchPointResults: { \"tracePoints\": [], \"connectData\": [], \"startNode\": [], \"diffSList\": [], \"diffGList\": [], \"interList\": [] },\n\n            // search table\n            searchPointCanvas2: null,\n            searchPointRegl2: null,\n            searchPointPositionBuffer2: null,\n            searchPointTextureCoordinateBuffer2: null,\n            searchPointResults2: [],\n\n            // Tooltips\n            tooltipTop: null,\n            tooltipBottom: null,\n            hoverPoint: null,\n\n            xScale: d3.scaleLinear(),\n            yScale: d3.scaleLinear(),\n\n            // zooming\n            zoom: null, // d3.ZoomBehavior<HTMLElement, unknown>\n            initZoomTransform: null,\n            curZoomTransform: d3.zoomIdentity,\n            curZoomLevel: 1,\n\n            // interaction\n            lastMouseClientPosition: null,\n            hideHighlights: false,\n\n            // user settings\n            showContours: [true],   // \n            showGrid: true,\n            showPoints: [true],\n            showPoints_back: false,\n            showLabel: false,\n            showTrace: true,\n\n            // data\n            dataURLs: null,\n            promptPoints: [],\n            gridData: null,\n            tileData: null,\n            contours: null,\n            groupContour: null,\n            contoursInitialized: false,\n            loadedPointCount: 1,\n\n            // Time\n            timeTextureMap: null,\n\n            // Group\n            groupNames: [],\n\n            // search\n            completedSearchQueryID: null,\n\n            // scatter plot\n            lastRefillID: 0,\n            lsatRefillTime: 0,\n            webGLMatrices: null,\n            curPointWidth: 1,\n\n            // display labels\n            topicLevelTrees: new Map(),\n            lastGridTreeLevels: [],\n\n            // Web workers\n            loaderWorker: null,\n            treeWorker: null,\n\n            // store\n            footerStoreValue: { xScale: null, embeddingName: null, numPoints: null },\n\n\n            // other top\n            DEBUG: config.debug,\n\n            handledFooterMessageID: 0,\n\n\n            // canvas points dis\n            pointsDict: [{}],\n\n\n        };\n    },\n    mounted() {\n\n        this.init();\n\n    },\n    methods: {\n        init() {\n\n            const dag = this.$refs.distributionMain;\n            this.svgFullSize.height = dag.clientHeight;\n            this.svgFullSize.width = dag.clientWidth;\n\n            console.log(\"dis \", this.svgFullSize.height, this.svgFullSize.width)\n\n            this.component = d3.select('.distribution-main');\n\n            // init worker\n            this.initWorker();\n\n            // init svg and canvas\n            const squareCanvasWidth = Math.min(\n                this.svgFullSize.width - this.svgPadding.left - this.svgPadding.right,\n                this.svgFullSize.height - this.svgPadding.top - this.svgPadding.bottom\n            );\n\n            this.svgSize = {\n                width: squareCanvasWidth,\n                height: squareCanvasWidth\n            };\n\n            this.initTopSvg();\n            this.initCanvas();\n            this.initSVGGroups();\n\n            // Register zoom\n            this.zoom = d3\n                .zoom()\n                .extent([\n                    [0, 0],\n                    [this.svgSize.width, this.svgSize.height]\n                ])\n                .scaleExtent([config.layout.zoomScale[0], config.layout.zoomScale[1]])\n                .interpolate(d3.interpolate)\n                .on('zoom', (g) => {\n                    (async () => {\n                        await this.zoomed(g);\n                    })();\n                })\n                .on('end', () => this.zoomEnded());\n\n            this.topSvg.call(this.zoom).on('dblclick.zoom', null);\n\n            this.tooltipTop = document.querySelector('#popper-tooltip-top');\n            this.tooltipBottom = document.querySelector('#popper-tooltip-bottom');\n\n            // init data\n            this.initData().then(() => {\n\n                Embedder.displayGroupChanged(this, \"Image\");\n\n\n            });\n\n        },\n        async initData() {\n\n            const gridData = await d3.json(this.$store.state.dataURLs.grid);\n            if (gridData === undefined) {\n                console.log('Fail to load grid data');\n            }\n\n            this.gridData = gridData;\n\n            // Initialize the data scales\n            const xRange = this.gridData.xRange;\n            const yRange = this.gridData.yRange;\n\n            let xLength = xRange[1] - xRange[0];\n            let yLength = yRange[1] - yRange[0];\n\n            if (!this.gridData.padded) {\n                // Add padding for the data\n                if (xLength < yLength) {\n                    yRange[0] -= yLength / 50;\n                    yRange[1] += yLength / 50;\n                    yLength = yRange[1] - yRange[0];\n\n                    xRange[0] -= (yLength - xLength) / 2;\n                    xRange[1] += (yLength - xLength) / 2;\n                } else {\n                    // Add padding for the data\n                    xRange[0] -= xLength / 50;\n                    xRange[1] += xLength / 50;\n                    xLength = xRange[1] - xRange[0];\n\n                    yRange[0] -= (xLength - yLength) / 2;\n                    yRange[1] += (xLength - yLength) / 2;\n                }\n            }\n\n            this.xScale = d3\n                .scaleLinear()\n                .domain(xRange)\n                .range([0, this.svgSize.width]);\n\n            this.yScale = d3\n                .scaleLinear()\n                .domain(yRange)\n                .range([this.svgSize.height, 0]);\n\n            PointDrawer.drawContour(this);  //  group \n\n            // Create group related structures if the data has groups\n            if (this.gridData.groupGrids && this.gridData.groupNames.length > 0) {\n                this.groupNames = this.gridData.groupNames;\n                const umapGroup = this.svg.select('g.umap-group');\n\n                // Adjust the first contour's name\n                this.showContours = [];\n                this.showPoints = [];\n                this.groupContours = [];\n\n                for (let i = 0; i < this.groupNames.length; i++) {\n                    // Add groups to the control states\n                    // (Default is to show the first group only)\n                    this.showContours.push(i === 0);    // \n                    this.showPoints.push(i === 0);\n\n                    // Add contour elements for other groups\n                    const name = this.groupNames[i];\n                    umapGroup\n                        .append('g')\n                        .attr('class', `contour-group-generic contour-group-${name}`)\n                        .classed('hidden', i !== 0);\n\n                    // Drw the group contour\n                    const curContour = PointDrawer.drawGroupContour(this, name);\n                    if (curContour !== null) {\n                        this.groupContours.push(curContour);\n                    }\n                }\n            }\n\n            // Tell the tree worker to prepare to add points to the tree\n            const groupIDs = [];\n\n            if (this.groupNames) {\n                for (let i = 0; i < this.groupNames.length; i++) {\n                    groupIDs.push(i);\n                }\n            }\n\n            const treeMessage = {\n                command: 'initQuadtree',\n                payload: {\n                    xRange: xRange,\n                    yRange: yRange,\n                    groupIDs: groupIDs,\n                    times: []\n                }\n            };\n\n            this.treeWorker.postMessage(treeMessage);\n\n            for (const level of Object.keys(this.gridData.topic.data)) {\n                const tree = d3\n                    .quadtree()\n                    .x(function (d) { return d[0]; })\n                    .y(function (d) { return d[1]; })\n                    .addAll(this.gridData.topic.data[level]);\n                this.topicLevelTrees.set(parseInt(level, 10), tree);\n            }\n\n            //  topic label \n\n\n            // Initialize WebGL matrices once we have the scales\n            PointDrawer.initWebGLMatrices(this);\n            PointDrawer.initWebGLBuffers(this);\n\n        },\n        initCanvas() {\n\n            const discomponent = this.$refs.distributionMain;\n\n            this.searchPointCanvas = d3.select(discomponent)\n                .append('canvas')\n                .attr('class', 'search-point-canvas')\n                .classed('hidden', true)\n                .attr('width', this.svgFullSize.width)\n                .attr('height', this.svgFullSize.height);\n\n            this.searchPointRegl = createRegl(this.searchPointCanvas?.node());\n\n            this.pointCanvas = d3.select(discomponent)\n                .append('canvas')\n                .attr('class', 'embedding-canvas')\n                .attr('width', this.svgFullSize.width)\n                .attr('height', this.svgFullSize.height);\n\n            this.pointRegl = createRegl(this.pointCanvas?.node());\n\n            this.topicCanvases = [];\n            for (const pos of ['top', 'bottom']) {\n                this.topicCanvases.push(\n                    d3\n                        .select(discomponent)\n                        .append('canvas')\n                        .attr('class', `topic-grid-canvas ${pos}`)\n                        .attr('width', `${this.svgFullSize.width}px`)\n                        .attr('height', `${this.svgFullSize.height}px`)\n                        .classed('hidden', !this.showGrid)\n                );\n            }\n\n        },\n        initSVGGroups() {\n\n            this.svg = this.component.append('svg')\n                .attr('class', \"embedding-svg\")\n                .attr('width', this.svgFullSize.width)\n                .attr('height', this.svgFullSize.height);\n\n\n            const umapGroup = this.svg\n                .append('g')\n                .attr('class', 'umap-group')\n                .attr(\n                    'transform',\n                    `translate(${this.svgPadding.left}, ${this.svgPadding.top})`\n                );\n\n            umapGroup\n                .append('g')\n                .attr('class', 'contour-group')\n                .classed('hidden', !this.showContours);\n\n        },\n        initTopSvg() {\n\n            //  SVG \n            this.topSvg = this.component.append('svg')\n                .attr('class', \"top-svg\")\n                .attr('width', `${this.svgFullSize.width}px`)\n                .attr('height', `${this.svgFullSize.height}px`) // \n                .on('pointermove', e => this.mousemoveHandler(e))\n                .on('mouseleave', () => {\n                    PointDrawer.highlightPoint(this, { point: undefined, animated: false });\n                    Labeler.mouseoverLabel(this, null, null);\n                })\n                .attr(\n                    'transform',\n                    `translate(${this.svgPadding.left}, ${this.svgPadding.top})`\n                );\n\n\n            const topGroup = this.topSvg.append('g').attr('class', 'top-group');\n\n            topGroup\n                .append('rect')\n                .attr('class', 'mouse-track-rect')\n                .attr('width', this.svgFullSize.width)\n                .attr('height', this.svgFullSize.height);\n\n            const topContent = topGroup.append('g').attr('class', 'top-content');\n\n            topContent.append('g').attr('class', 'topics-bottom');\n            topContent\n                .append('g')\n                .attr('class', 'topics')\n                .classed('hidden', !this.showLabel);\n            topContent.append('g').attr('class', 'topics-top');\n            topContent.append('g').attr('class', 'highlights');\n\n        },\n        zoomed(e) {\n\n            const transform = e.transform;\n            const scaleChanged = this.curZoomTransform.k !== transform.k;\n            this.curZoomTransform = transform;\n\n            // === Task (1) ===\n            // Transform the SVG elements\n            this.svg.select('.umap-group').attr('transform', transform.toString());\n\n            // Transform the top SVG elements\n            this.topSvg\n                .select('.top-group')\n                .attr('transform', transform.toString());\n\n            // Transform the visible canvas elements\n            console.log(\" showPoints \", this.showPoints)\n            if (anyTrue(this.showPoints)) {\n                if (this.frontPositionBuffer && this.frontTextureCoordinateBuffer) {\n                    PointDrawer.drawScatterPlot(this);\n                }\n            }\n\n            // Transform the search scatter plot\n            if (this.showTrace) {\n\n                console.log(\"trace \", this.showTrace)\n\n                this.searchPointCanvas.classed('hidden', false);\n                this.pointCanvas.classed('faded', true);\n\n                PointDrawer.drawSearchScatterPlot(this);\n\n            }\n\n            if (this.searchPointResults2.length > 0) {\n\n                this.searchPointCanvas.classed('hidden', false);\n                this.pointCanvas.classed('faded', true);\n\n                PointDrawer.drawSearchScatterPlot2(this);\n\n            }\n\n            if (this.showGrid) {\n                Labeler.redrawTopicGrid(this, null);\n            }\n\n\n        },\n        // Event handler for zoom ended\n        zoomEnded() {\n            console.log(\"svg zoom end !!!\")\n        },\n        initWorker() {\n            // Initialize the web worker to load data and deal with the quadtree\n            this.loaderWorker = new LoaderWorker();\n            this.loaderWorker.onmessage = (e) => {\n                this.loaderWorkerMessageHandler(e);\n            };\n\n            this.treeWorker = new TreeWorker();\n            this.treeWorker.onmessage = (e) => {\n                this.treeWorkerMessageHandler(e);\n            };\n\n            // this.searchWorker = new SearchWorker();\n            // this.searchWorker.onmessage = (e) => {\n            //     this.searchWorkerMessageHandler(e);\n            // };\n        },\n        loaderWorkerMessageHandler(e) {\n            switch (e.data.command) {\n                case 'transferLoadData': {\n                    // Add these points to the quadtree ASAP\n                    const treeMessage = {\n                        command: 'updateQuadtree',\n                        payload: {\n                            points: e.data.payload.points\n                        }\n                    };\n                    this.treeWorker.postMessage(treeMessage);\n\n                    if (e.data.payload.isFirstBatch) {\n\n                        // Add the first batch points\n                        this.promptPoints = e.data.payload.points;\n\n\n                        PointDrawer.initWebGLBuffers(this);\n                        if (anyTrue(this.showPoints)) {\n                            PointDrawer.drawScatterPlot(this);\n                        }\n\n                        // Add the points to the search index\n                        const searchMessage = {\n                            command: 'addPoints',\n                            payload: {\n                                points: e.data.payload.points\n                            }\n                        };\n                        // this.searchWorker.postMessage(searchMessage);\n                    } else {\n                        // Batches after the first batch\n                        // Add the points to the prompt point list\n                        const newPoints = e.data.payload.points;\n                        for (const point of newPoints) {\n                            this.promptPoints.push(point);\n                        }\n\n                        // Add the points to the search index\n                        // const searchMessage = {\n                        //     command: 'addPoints',\n                        //     payload: {\n                        //         points: newPoints\n                        //     }\n                        // };\n                        // this.searchWorker.postMessage(searchMessage);\n\n                        // Add the new points to the WebGL buffers\n                        PointDrawer.updateWebGLBuffers(this, newPoints);\n                        if (anyTrue(this.showPoints)) {\n                            PointDrawer.drawScatterPlot(this);\n                        }\n\n                        if (e.data.payload.isLastBatch) {\n                            console.log('Finished loading all data.');\n\n                            // console.log(\" this.prompt \", this.promptPoints)\n                            this.getPointsDis();\n                        }\n\n\n                    }\n\n                    // Update the data point count\n                    this.loadedPointCount = e.data.payload.loadedPointCount;\n\n                    // Update the footer\n                    this.footerStoreValue.numPoints = this.promptPoints.length;\n                    // this.footerStore.set(this.footerStoreValue);\n                    break;\n                }\n\n                default: {\n                    console.error('Unknown message', e.data.command);\n                    break;\n                }\n            }\n        },\n\n        treeWorkerMessageHandler(e) {\n            switch (e.data.command) {\n                case 'finishInitQuadtree': {\n                    // Tell the loader worker to start loading data\n                    // (need to wait to set up the quadtree to avoid racing)\n                    const message = {\n                        command: 'startLoadData',\n                        payload: { url: this.$store.state.dataURLs.point }\n                    };\n                    this.loaderWorker.postMessage(message);\n                    break;\n                }\n\n                case 'finishQuadtreeSearch': {\n                    if (this.lastMouseClientPosition === null) {\n                        throw new Error('lastMouseClientPosition is null');\n                    }\n                    // Check if the closest point is relatively close to the mouse\n                    const closestPoint = structuredClone(\n                        e.data.payload.point\n                    );\n                    const screenPointX = this.curZoomTransform.applyX(\n                        this.xScale(closestPoint.x)\n                    );\n                    const screenPointY = this.curZoomTransform.applyY(\n                        this.yScale(closestPoint.y)\n                    );\n\n                    const distance = Math.max(\n                        Math.abs(screenPointX - this.lastMouseClientPosition.x),\n                        Math.abs(screenPointY - this.lastMouseClientPosition.y)\n                    );\n\n                    const highlightRadius = Math.max(\n                        10 / this.curZoomTransform.k,\n                        (config.layout.scatterDotRadius *\n                            Math.exp(Math.log(this.curZoomTransform.k) * 0.55)) /\n                        this.curZoomTransform.k\n                    );\n\n                    // Highlight the point if it is close enough to the mouse\n                    const curHoverRadius = Math.max(\n                        HOVER_RADIUS,\n                        highlightRadius * this.curZoomTransform.k\n                    );\n\n                    if (distance <= curHoverRadius) {\n                        PointDrawer.highlightPoint(this, { point: closestPoint, animated: false });\n                    } else {\n                        PointDrawer.highlightPoint(this, { point: undefined, animated: false });\n                    }\n                    break;\n                }\n\n\n                case 'finishQuadtreeSearchById': {\n\n                    // Check if the closest point is relatively close to the mouse\n                    const closestPoint = structuredClone(\n                        e.data.payload.point\n                    );\n                    const screenPointX = this.curZoomTransform.applyX(\n                        this.xScale(closestPoint.x)\n                    );\n                    const screenPointY = this.curZoomTransform.applyY(\n                        this.yScale(closestPoint.y)\n                    );\n\n                    const highlightRadius = Math.max(\n                        10 / this.curZoomTransform.k,\n                        (config.layout.scatterDotRadius *\n                            Math.exp(Math.log(this.curZoomTransform.k) * 0.55)) /\n                        this.curZoomTransform.k\n                    );\n\n                    // Highlight the point if it is close enough to the mouse\n                    const curHoverRadius = Math.max(\n                        HOVER_RADIUS,\n                        highlightRadius * this.curZoomTransform.k\n                    );\n\n                    if (e.data.payload.point) {\n                        PointDrawer.highlightPoint(this, { point: closestPoint, animated: false });\n                    } else {\n                        PointDrawer.highlightPoint(this, { point: undefined, animated: false });\n                    }\n                    break;\n                }\n\n\n\n                default: {\n                    console.error('Unknown message', e.data.command);\n                    break;\n                }\n            }\n        },\n\n        searchWorkerMessageHandler(e) {\n            switch (e.data.command) {\n                case 'finishQuery': {\n                    const { resultIndexes } = e.data.payload;\n                    const resultPoints = [];\n\n                    for (const resultIndex of resultIndexes) {\n                        const curPoint = this.promptPoints[resultIndex];\n                        resultPoints.push(curPoint);\n                    }\n\n                    // Update the search panel\n                    // this.searchBarStoreValue.results = resultPoints;\n                    // this.searchBarStoreValue.shown = true;\n                    // this.searchBarStore.set(this.searchBarStoreValue);\n\n                    // Draw the scatter plot\n                    this.searchPointCanvas.classed('hidden', false);\n                    this.searchPointResults = resultPoints;\n                    PointDrawer.drawSearchScatterPlot(this);\n                    break;\n                }\n\n                default: {\n                    console.error('Unknown message', e.data.command);\n                    break;\n                }\n            }\n        },\n\n        mouseoverPoint(x, y) {\n            // Invert to the stage scale => invert to the data scale\n            const dataX = this.xScale.invert(this.curZoomTransform.invertX(x));\n            const dataY = this.yScale.invert(this.curZoomTransform.invertY(y));\n\n            // Let the worker to search the closest point in a radius\n            let groupID = -1;\n\n            if (this.groupNames) {\n                if (allTrue(this.showPoints)) {\n                    groupID = -1;\n                } else {\n                    // TODO: Need a better way to search slices of groups for multi groups\n                    for (let i = 0; i < this.showPoints.length; i++) {\n                        if (this.showPoints[i]) {\n                            groupID = i;\n                            break;\n                        }\n                    }\n                }\n            }\n\n            const message = {\n                command: 'startQuadtreeSearch',\n                payload: {\n                    x: dataX,\n                    y: dataY,\n                    time: this.timeInspectMode && this.curTime ? this.curTime : '',\n                    groupID: groupID,\n                    method: null\n                }\n            };\n            this.treeWorker.postMessage(message);\n        },\n\n        mousemoveHandler(e) {\n            // Show tooltip when mouse over a data point on canvas\n            // We need to use color picking to figure out which point is hovered over\n            const x = e.offsetX;\n            const y = e.offsetY;\n            this.lastMouseClientPosition = { x: x, y: y };\n\n            // Show point highlight\n            if (anyTrue(this.showPoints) && !this.hideHighlights) {\n                this.mouseoverPoint(x, y);\n            }\n\n            // Show labels\n            if (!this.hideHighlights) {\n                Labeler.mouseoverLabel(this, x, y);\n            }\n        },\n\n        getCurZoomBox() {\n            const box = {\n                x: this.curZoomTransform.invertX(0),\n                y: this.curZoomTransform.invertY(0),\n                width: Math.abs(\n                    this.curZoomTransform.invertX(this.svgFullSize.width) -\n                    this.curZoomTransform.invertX(0)\n                ),\n                height: Math.abs(\n                    this.curZoomTransform.invertY(this.svgFullSize.height) -\n                    this.curZoomTransform.invertY(0)\n                )\n            };\n            return box;\n        },\n        getSearchTraceData() {\n\n            // \n\n            // 1.  node-link \n            // 2. {\"gt not search\": [], \"search&gt\": [], \"search not gt\": []}\n\n            // const resultPoints = [];\n\n            // for (const resultIndex of resultIndexes) {\n            //     const curPoint = this.promptPoints[resultIndex];\n            //     resultPoints.push(curPoint);\n            // }\n\n            // Draw the scatter plot\n            this.searchPointCanvas.classed('hidden', false);\n            this.pointCanvas.classed('faded', true);\n            // this.searchPointResults = resultPoints;\n            PointDrawer.drawSearchScatterPlot(this);\n\n        },\n        getSearchByIdResult(selectedNode) {\n            //  id node \n            console.log(\"pos-----------\", this.promptPoints[selectedNode]);\n\n            const dataX = this.promptPoints[selectedNode].x;\n            const dataY = this.promptPoints[selectedNode].y;\n\n            // Let the worker to search the closest point in a radius\n            let groupID = -1;\n\n            if (this.groupNames) {\n                if (allTrue(this.showPoints)) {\n                    groupID = -1;\n                } else {\n                    // TODO: Need a better way to search slices of groups for multi groups\n                    for (let i = 0; i < this.showPoints.length; i++) {\n                        if (this.showPoints[i]) {\n                            groupID = i;\n                            break;\n                        }\n                    }\n                }\n            }\n\n            const message = {\n                command: 'startQuadtreeSearchById',\n                payload: {\n                    point: this.promptPoints[selectedNode],\n                    method: 'id'\n                }\n            };\n            this.treeWorker.postMessage(message);\n        },\n        getPointsDis() {\n\n            // \n            console.log(\"   dis\", this.promptPoints)\n\n            const pairPoints = [96525, 108791, 166518, 267176, 33103, 165549, 203193, 290725, 25731, 113572, 141181, 204376, 284997, 222524, 128324, 156231, 205478, 65275, 92693, 2609, 18517, 39219, 290535, 153897, 234501, 230064, 132706, 232534, 20106, 51369, 181971, 279546, 169313, 129455, 103872, 177641, 53790, 82080, 11950, 285777, 120341, 210428, 103481, 264413, 113056, 152719, 45621, 180558, 176928, 250723, 116622, 128458, 36924, 16817, 259438, 279062, 51396, 101666, 33561, 258777, 157548, 142826, 169862, 160716, 209716, 101040, 183063, 107639, 14869, 114479, 118693, 154047, 200534, 60525, 263843, 185383, 82329, 41903, 252541, 286431, 265292, 153150, 39432, 276085, 120819, 142210, 98553, 64439, 256844, 71370, 22427, 49592, 228182, 120339, 29153, 230946, 299630, 116558, 250299, 125909, 216661, 288813, 48003, 117204, 192909, 187202, 215129, 273241, 138807, 196661, 26875, 79750, 104866, 45695, 204431, 231573, 76216, 102253, 125634, 251827, 247382, 81156, 57798, 34194, 87647, 186840, 79844, 295326, 256396, 32080, 10534, 200505, 273922, 33574, 8125, 8366, 291137, 145952, 98829, 39600, 242407, 101295, 238727, 185926, 201797, 62769, 182167, 225255, 269142, 5048, 17984, 260328, 108197, 67602, 2789, 291329, 36452, 158003, 181298, 194478, 208707, 47127, 223622, 200454, 226092, 3444, 227919, 125815, 96932, 124366, 41067, 240765, 109817, 267532, 143381, 200455, 213220, 64279, 135312, 212277, 89614, 19436, 266613, 56906, 6355, 155155, 122551, 283878, 15843, 189202, 293525, 71544, 61158, 126463, 113547, 230063, 58517, 225333, 148556, 243662, 228835, 16921, 241481, 270759, 239354, 223058, 298963, 18739, 295330, 186860, 38381, 162262, 207826, 238198, 55402, 92327, 253749, 62054, 229492, 20965, 280649, 44071, 47853, 192277, 161674, 58113, 18659, 126469, 269440, 179573, 273425, 150322, 46184, 159308, 92535, 191964, 269188, 108708, 172607, 41916, 194217, 242881, 208102, 154381, 20667, 27823, 29086, 276074, 11601, 54928, 1422, 183569, 157972, 184539, 122516, 113357, 79314, 262263, 54208, 277314, 243997, 90137, 275614, 16712, 125488, 165567, 27224, 251775, 110452, 20451, 105315, 136280, 88956, 175644, 121565, 217059, 168285, 247779, 185333, 237968, 4641, 23299, 138405, 272321, 87224, 142514, 90695, 150176, 124845, 216678, 299506, 211529, 4635, 213657, 65424, 131629, 20418, 230397, 82933, 285097, 186596, 218834, 262197, 109567, 249712, 159931, 228616, 111108, 246682, 52478, 57957, 77799, 186600, 70789, 184529, 204423, 217347, 113794, 274530, 109148, 86755, 291649, 59476, 105307, 64810, 207949, 70335, 59877, 228282, 150253, 130291, 112660, 53281, 171966, 186932, 59417, 157583, 83485, 185219, 33323, 50480, 157148, 110532, 154150, 288440, 186347, 224698, 77624, 227482, 214719, 66166, 95340, 60063, 248970, 133719, 207652, 31596, 285623, 209248, 164301, 40212, 144978, 24009, 272494, 253731, 13797, 236337, 93758, 98806, 135870, 244261, 240947, 140480, 296523, 231270, 55139, 210617, 286252, 251160, 104473, 269914, 40178, 160338, 169217, 51209, 159755, 27301, 164035, 202364, 135088, 231042, 116528, 59344, 125474, 181234, 92116, 28161, 172540, 212861, 101411, 24795, 93445, 7901, 40312, 266139, 118767, 40834, 3142, 166640, 244874, 230754, 269489, 296822, 292201, 126347, 10634, 201863, 232392, 272474, 57609, 54609, 183802, 250954, 23888, 157861, 177705, 214531, 70321, 176092, 249452, 55092, 68756, 270535, 149866, 106861, 51350, 269887, 105070, 83159, 120789, 250386, 69339, 218537, 179332, 221361, 270419, 8418, 280065, 36882, 117107, 292747, 145218, 108904, 171299, 119896, 298225, 204699, 121976, 209283, 41518, 263710, 225568, 261042, 99435, 56127, 84079, 279377, 140428, 214007, 146826, 262048, 279419, 297456, 223862, 68097, 286644, 27381, 54550, 46607, 140179, 88747, 201891, 30434, 128226, 212330, 220723, 180346, 296818, 86749, 173691, 195657, 161674, 82835, 293196, 184195, 241395, 72943, 51262, 295953, 170439, 139628, 203068, 54943, 267396, 39290, 66706, 140989, 266486, 201374, 174152, 99448, 67779, 68027, 18605, 272853, 295708, 191181, 218387, 73742, 29844, 21149, 283123, 142684, 235872, 107439, 55957, 208758, 170697, 170444, 278989, 128178, 117241, 223899, 212834, 90869, 15371, 224918, 107179, 242051, 131299, 176454, 180188, 196393, 276231, 39202, 202778, 268749, 209173, 275214, 91992, 170261, 103772, 142105, 164435, 289253, 4554, 238056, 249955, 13549, 99610, 193419, 220973, 110199, 17858, 149100, 228404, 133768, 193866, 172504, 136070, 170865, 218487, 18102, 265418, 54028, 46223, 65269, 117192, 271015, 43732, 208927, 72260, 57472, 139983, 47535, 142098, 233152, 158219, 156764, 296628, 259867, 15812, 227223, 148096, 184082, 285707, 175790, 117974, 125510, 231407, 225929, 259460, 148379, 12452, 100993, 272527, 35186, 137566, 40652, 204943, 212306, 262011, 177405, 81923, 218707, 251966, 133026, 108271, 24697, 299195, 167025, 209933, 237416, 83348, 188919, 48162, 63841, 130230, 113140, 12014, 126847, 227095, 167883, 213519, 90553, 273911, 91002, 81837, 62325, 193369, 175586, 30192, 42094, 111399, 130873, 181116, 274534, 210079, 135332, 142538, 22333, 209918, 151836, 8422, 147236, 38228, 133982, 198759, 242971, 96437, 123963, 222716, 28371, 251243, 14006, 43665, 280981, 19067, 247704, 161839, 103530, 82622, 261433, 264603, 77623, 142509, 50716, 34298, 76983, 16377, 293188, 274216, 169852, 245588, 168089, 47123, 46734, 43665, 193138, 222658, 119512, 234976, 23331, 155950, 183042, 101852, 266050, 182257, 19886, 128818, 247127, 43646, 782, 90487, 216474, 269093, 86035, 169670, 250042, 271904, 231929, 88572, 249342, 105928, 72211, 134552, 195038, 58973, 269360, 56593, 151720, 184903, 272442, 224599, 272327, 5657, 163259, 118890, 124569, 181669, 143508, 225400, 26385, 30979, 87135, 87033, 175041, 62019, 152548, 14244, 64621, 241937, 251174, 275872, 162503, 31867, 131883, 56281, 220580, 149602, 89349, 282523, 182188, 101007, 253662, 209049, 95977, 230437, 108382, 170769, 146442, 79761, 223687, 295653, 160832, 179661, 192962, 161793, 85291, 40010, 263394, 26760, 28814, 272363, 164907, 178172, 147834, 77194, 162434, 120583, 46237, 138420, 58688, 106685, 117945, 191328, 285934, 277033, 38591, 131219, 215862, 173865, 264971, 5986, 110651, 86616, 244510, 15598, 134368, 237964, 205548, 190833, 58045, 201511, 244387, 96306, 43579, 280347, 297190, 10155, 285687, 124706, 273017, 54085, 35796, 65766, 250597, 192827, 235450, 59065, 147448, 184323, 65348, 111190, 267785, 200355, 67548, 29115, 141665, 7646, 47767, 181962, 12770, 44821, 1008, 138547, 52976, 84360, 159903, 280401, 42734, 58007, 220363, 205722, 102482, 41437, 52758, 111405, 119752, 184427, 46874, 42254, 128973, 109681, 32100, 182891, 115614, 97456, 225430, 99241, 176100, 147085, 116409, 85626, 182066, 125830, 227070, 42042, 139036, 173841, 104576, 16728, 297659, 137785, 189368, 233663, 5538, 92347, 150000, 181773, 44039, 245278, 261211, 152592, 44811, 132237, 49767, 222695, 69070, 173146, 142780, 41955, 191395, 210404, 290183, 8562, 172350, 234195, 258609, 146913, 196146, 244481, 169378, 224385, 193138, 149219, 128111, 12607, 251089, 236471, 66874, 109072, 175010, 198604, 248051, 158612, 189445, 250428, 225950, 169923, 195311, 75579, 282830, 245469, 4883, 44877, 95906, 77577, 255922, 193139, 181187, 60120, 279168, 188165, 252834, 165188, 242748, 2321, 131471, 120852, 254712, 27430, 265988, 214831, 13085, 125938, 293196, 232600, 170377, 35288, 199193, 185330, 202646, 29431, 3856, 169368, 132964, 265439, 242042, 204505, 15689, 50935, 229315, 13752, 19339, 206656, 166732, 199176, 277016, 174063, 150075, 126544, 75153, 238447, 27100, 50740, 234487, 65040, 159800, 28762, 210305, 33987, 8885, 157993, 210485, 144775, 138802, 157708, 63443, 225395, 89015, 279512, 179898, 51272, 37938, 143799, 42932, 89450, 24671, 263725];\n\n            // \n            console.log(pairPoints);\n\n            let dis_list = [];\n\n            // \n            const { dataScaleMatrix, normalizeMatrix } = this.webGLMatrices;\n\n            \n            // \n            function applyMatrix(matrix, point) {\n                const x = point.x;\n                const y = point.y;\n                const w = 1; // \n\n                return {\n                    x: matrix[0][0] * x + matrix[0][1] * y + matrix[0][2] * w,\n                    y: matrix[1][0] * x + matrix[1][1] * y + matrix[1][2] * w,\n                    w: matrix[2][0] * x + matrix[2][1] * y + matrix[2][2] * w\n                };\n            }\n\n            for (const pair of pairPoints) {\n                // \n                const startNode = {x:this.promptPoints[pair].x, y: this.promptPoints[pair].y};\n                const endNode = {x:this.promptPoints[pair + 300000].x, y: this.promptPoints[pair + 300000].y};\n                // \n                // \n                // const stagePoint = applyMatrix(dataScaleMatrix, startNode);\n                // const pixelPoint = applyMatrix(normalizeMatrix, stagePoint);\n\n                // const stagePoint_end = applyMatrix(dataScaleMatrix, endNode);\n                // const pixelPoint_end = applyMatrix(normalizeMatrix, stagePoint_end);\n\n                const x0 = this.xScale(startNode.x);\n                const y0 = this.yScale(startNode.y);\n\n                const x1 = this.xScale(endNode.x);\n                const y1 = this.yScale(endNode.y);\n\n\n                console.log(\"endNode\", endNode);\n\n                const dis = Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));\n\n                dis_list.push(dis);\n\n            }\n\n            //  dis_list \n            //  dis_list \n            const averageDis = dis_list.reduce((sum, value) => sum + value, 0) / dis_list.length;\n\n            console.log(\"dis_list\", dis_list);\n            console.log(\"Average distance:\", averageDis);\n\n        }\n\n    },\n    computed: {\n        ...mapState({\n            iconShow: \"iconShow\",\n            dataNodeLink: \"dataNodeLink\",\n            selectedNode: \"selectedNode\",\n            tableFiterResults: \"tableFiterResults\"\n        }),\n    },\n    watch: {\n        iconShow: {\n            handler(newVal, oldVal) {\n                this.showGrid = newVal.grid;\n                this.topicCanvases.forEach(c => {\n                    c.classed('hidden', !this.showGrid);\n                });\n\n                this.showTrace = newVal.trace;\n                this.searchPointCanvas.classed('hidden', !this.showTrace);\n                this.pointCanvas.classed('faded', this.showTrace);\n\n                console.log(\"show\", newVal, oldVal)\n\n                if (newVal.points !== this.showPoints_back) {\n                    //  map \n                    this.showPoints = this.showPoints.map(point => !point);\n                    this.pointCanvas\n                        .classed('hidden', !newVal.points)\n                        .classed('faded', newVal.points);\n                    this.searchPointCanvas.classed('hidden', newVal.points);\n                    this.showPoints_back = !this.showPoints_back;\n\n                }\n            },\n            deep: true,\n        },\n        dataNodeLink(newVal, oldVal) {\n            if (newVal != oldVal) {\n                this.getSearchTraceData();\n            }\n        },\n        selectedNode(newVal, oldVal) {\n            if (newVal !== oldVal & newVal !== '-1') {\n                console.log(\"\", typeof newVal)\n                this.getSearchByIdResult(newVal);\n\n            }\n\n\n        },\n        tableFiterResults(newVal) {\n\n            if (newVal.length > 0) {\n\n                const resultList = []\n\n                for (const resultIndex of newVal) {\n                    const curPoint = this.promptPoints[resultIndex];\n                    resultList.push(curPoint);\n                }\n                this.searchPointResults2 = resultList;\n                this.searchPointCanvas.classed('hidden', false);\n                this.pointCanvas.classed('faded', true);\n\n                PointDrawer.drawSearchScatterPlot2(this);\n\n\n            }\n        }\n    }\n};\n\n\n</script>\n\n<style lang=\"scss\">\n@use './DistributionView.scss';\n</style>"]}]}