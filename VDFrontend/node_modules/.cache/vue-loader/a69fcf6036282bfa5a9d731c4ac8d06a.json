{"remainingRequest":"/home/yansha/VDProject/VDFrontend/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/yansha/VDProject/VDFrontend/src/views/MainView/MiddleMainView/DistributionView.vue?vue&type=script&lang=js","dependencies":[{"path":"/home/yansha/VDProject/VDFrontend/src/views/MainView/MiddleMainView/DistributionView.vue","mtime":1735832331659},{"path":"/home/yansha/VDProject/VDFrontend/node_modules/cache-loader/dist/cjs.js","mtime":1735202380381},{"path":"/home/yansha/VDProject/VDFrontend/node_modules/babel-loader/lib/index.js","mtime":1735202380921},{"path":"/home/yansha/VDProject/VDFrontend/node_modules/cache-loader/dist/cjs.js","mtime":1735202380381},{"path":"/home/yansha/VDProject/VDFrontend/node_modules/vue-loader/lib/index.js","mtime":1735202381045}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CmltcG9ydCB7IG1hcFN0YXRlIH0gZnJvbSAidnVleCI7CmltcG9ydCB7IGNvbmZpZyB9IGZyb20gJ0AvY29uZmlnL2NvbmZpZyc7CmltcG9ydCBjcmVhdGVSZWdsIGZyb20gJ3JlZ2wnOwppbXBvcnQgZDMgZnJvbSAnLi4vLi4vLi4vdXRpbHMvZDMtaW1wb3J0JzsKaW1wb3J0IHsgaW5pdFdlYkdMTWF0cmljZXMsIGluaXRXZWJHTEJ1ZmZlcnMsIGRyYXdTY2F0dGVyUGxvdCwgZHJhd0dyb3VwQ29udG91ciwgdXBkYXRlV2ViR0xCdWZmZXJzLCBhbnlUcnVlLCBhbGxUcnVlLCBoaWdobGlnaHRQb2ludCwgZGlzcGxheUdyb3VwQ2hhbmdlZCB9IGZyb20gJy4uLy4uLy4uL2NvbXBvbmVudHMvRW1iZWRkaW5nL0VtYmVkZGluZyc7CmltcG9ydCB7IHJlZHJhd1RvcGljR3JpZCwgbW91c2VvdmVyTGFiZWwgfSBmcm9tICcuLi8uLi8uLi9jb21wb25lbnRzL0VtYmVkZGluZy9FbWJlZGRpbmdMYWJlbCc7CmltcG9ydCBMb2FkZXJXb3JrZXIgZnJvbSAnLi4vLi4vLi4vY29tcG9uZW50cy9FbWJlZGRpbmcvd29ya2Vycy9sb2FkZXIud29ya2VyLmpzJzsKaW1wb3J0IFRyZWVXb3JrZXIgZnJvbSAnLi4vLi4vLi4vY29tcG9uZW50cy9FbWJlZGRpbmcvd29ya2Vycy90cmVlLndvcmtlci5qcyc7CmltcG9ydCAqIGFzIFBvaW50RHJhd2VyIGZyb20gJy4uLy4uLy4uL2NvbXBvbmVudHMvRW1iZWRkaW5nL0VtYmVkZGluZ1BvaW50V2ViR0wnCmltcG9ydCB7IEhPVkVSX1JBRElVUyB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL3V0aWxzJzsKCmV4cG9ydCBkZWZhdWx0IHsKICAgIG5hbWU6ICJEaXN0cmlidXRpb25WaWV3IiwKICAgIGNvbXBvbmVudHM6IHsKCiAgICB9LAogICAgZGF0YSgpIHsKICAgICAgICByZXR1cm4gewogICAgICAgICAgICBjb21wb25lbnQ6IG51bGwsICAgIC8vIEhUTUxFbGVtZW5077yaIGQzLnNlbGVjdCgnLmRpc3RyaWJ1dGlvbi1tYWluJykKCiAgICAgICAgICAgIHN2ZzogbnVsbCwgICAgLy8gZDMuU2VsZWN0aW9uPEhUTUxFbGVtZW50LCB1bmtub3duLCBudWxsLCB1bmRlZmluZWQ+LCB1bnNlZCBmb3IgZHJhd2luZyBjb250b3VyCiAgICAgICAgICAgIHN2Z0Z1bGxTaXplOiB7IHdpZHRoOiAwLCBoZWlnaHQ6IDAgfSwgICAvLyBTaXplCiAgICAgICAgICAgIHN2Z1NpemU6IHsgd2lkdGg6IDAsIGhlaWdodDogMCB9LCAvLyBzcXVhcmUgZHJhdyAKICAgICAgICAgICAgc3ZnUGFkZGluZzogeyB0b3A6IDAsIGJvdHRvbTogMCwgbGVmdDogMCwgcmlnaHQ6IDAgfSwgLy8gUGFkZGluZwoKICAgICAgICAgICAgdG9wU3ZnOiBudWxsLCAgIC8vIGQzLlNlbGVjdGlvbjxIVE1MRWxlbWVudCwgdW5rbm93biwgbnVsbCwgdW5kZWZpbmVkPiwgdW5zZWQgZm9yIGRyYXdpbmcgaGlnaHRsaWdodHMKICAgICAgICAgICAgdG9waWNDYW52YXNlczogW10sICAvLyB1c2VkIGZvciBkcmF3aW5nIGVtYmVkZGluZyBwb2ludHMgYW5kIG90aGVycwoKICAgICAgICAgICAgLy8gcG9pbnRzCiAgICAgICAgICAgIHBvaW50Q2FudmFzOiBudWxsLAogICAgICAgICAgICBwb2ludFJlZ2w6IG51bGwsCiAgICAgICAgICAgIGZyb250UG9zaXRpb25CdWZmZXI6IG51bGwsCiAgICAgICAgICAgIGZyb250VGV4dHVyZUNvb3JkaW5hdGVCdWZmZXI6IG51bGwsCiAgICAgICAgICAgIGZyb250QnVmZmVyUG9pbnRTaXplOiAwLAoKICAgICAgICAgICAgLy8gc2VhcmNoCiAgICAgICAgICAgIHNlYXJjaFBvaW50Q2FudmFzOiBudWxsLAogICAgICAgICAgICBzZWFyY2hQb2ludFJlZ2w6IG51bGwsCiAgICAgICAgICAgIHNlYXJjaFBvaW50UG9zaXRpb25CdWZmZXI6IG51bGwsCiAgICAgICAgICAgIHNlYXJjaFBvaW50VGV4dHVyZUNvb3JkaW5hdGVCdWZmZXI6IG51bGwsCiAgICAgICAgICAgIHNlYXJjaFBvaW50UmVzdWx0czogbnVsbCwKCiAgICAgICAgICAgIC8vIFRvb2x0aXBzCiAgICAgICAgICAgIHRvb2x0aXBUb3A6IG51bGwsCiAgICAgICAgICAgIHRvb2x0aXBCb3R0b206IG51bGwsCiAgICAgICAgICAgIGhvdmVyUG9pbnQ6IG51bGwsCgogICAgICAgICAgICB4U2NhbGU6IG51bGwsCiAgICAgICAgICAgIHlTY2FsZTogbnVsbCwKCiAgICAgICAgICAgIC8vIHpvb21pbmcKICAgICAgICAgICAgem9vbTogbnVsbCwgLy8gZDMuWm9vbUJlaGF2aW9yPEhUTUxFbGVtZW50LCB1bmtub3duPgogICAgICAgICAgICBpbml0Wm9vbVRyYW5zZm9ybTogbnVsbCwKICAgICAgICAgICAgY3VyWm9vbVRyYW5zZm9ybTogbnVsbCwKICAgICAgICAgICAgY3VyWm9vbUxldmVsOiAxLAoKICAgICAgICAgICAgLy8gaW50ZXJhY3Rpb24KICAgICAgICAgICAgbGFzdE1vdXNlQ2xpZW50UG9zaXRpb246IG51bGwsCiAgICAgICAgICAgIGhpZGVIaWdobGlnaHRzOiBmYWxzZSwKCiAgICAgICAgICAgIC8vIHVzZXIgc2V0dGluZ3MKICAgICAgICAgICAgc2hvd0NvbnRvdXJzOiBbXSwKICAgICAgICAgICAgc2hvd0dyaWQ6IHRydWUsCiAgICAgICAgICAgIHNob3dQb2ludHM6IFtmYWxzZV0sCiAgICAgICAgICAgIHNob3dMYWJlbDogZmFsc2UsCgogICAgICAgICAgICAvLyBkYXRhCiAgICAgICAgICAgIGRhdGFVUkxzOiBudWxsLAogICAgICAgICAgICBwcm9tcHRQb2ludHM6IFtdLAogICAgICAgICAgICBncmlkRGF0YTogbnVsbCwKICAgICAgICAgICAgdGlsZURhdGE6IG51bGwsCiAgICAgICAgICAgIGNvbnRvdXJzOiBudWxsLAogICAgICAgICAgICBncm91cENvbnRvdXI6IG51bGwsCiAgICAgICAgICAgIGNvbnRvdXJzSW5pdGlhbGl6ZWQ6IGZhbHNlLAogICAgICAgICAgICBsb2FkZWRQb2ludENvdW50OiAxLAoKICAgICAgICAgICAgLy8gVGltZQogICAgICAgICAgICB0aW1lVGV4dHVyZU1hcDogbnVsbCwKCiAgICAgICAgICAgIC8vIEdyb3VwCiAgICAgICAgICAgIGdyb3VwTmFtZXM6IFtdLAoKICAgICAgICAgICAgLy8gc2VhcmNoCiAgICAgICAgICAgIGNvbXBsZXRlZFNlYXJjaFF1ZXJ5SUQ6IG51bGwsCgogICAgICAgICAgICAvLyBzY2F0dGVyIHBsb3QKICAgICAgICAgICAgd2ViR0xNYXRyaWNlczogbnVsbCwKICAgICAgICAgICAgY3VyUG9pbnRXaWR0aDogMSwKCiAgICAgICAgICAgIC8vIGRpc3BsYXkgbGFiZWxzCiAgICAgICAgICAgIHRvcGljTGV2ZWxUcmVlczogbmV3IE1hcCgpLAogICAgICAgICAgICBsYXN0R3JpZFRyZWVMZXZlbHM6IFtdLAoKCgogICAgICAgICAgICAvLyBXZWIgd29ya2VycwogICAgICAgICAgICBsb2FkZXJXb3JrZXI6IG51bGwsCiAgICAgICAgICAgIHRyZWVXb3JrZXI6IG51bGwsCgogICAgICAgICAgICAvLyBzdG9yZQogICAgICAgICAgICBmb290ZXJTdG9yZVZhbHVlOiB7IHhTY2FsZTogbnVsbCwgZW1iZWRkaW5nTmFtZTogbnVsbCwgbnVtUG9pbnRzOiBudWxsIH0sCgoKICAgICAgICAgICAgLy8gb3RoZXIgdG9wCiAgICAgICAgICAgIERFQlVHOiBjb25maWcuZGVidWcsCgogICAgICAgICAgICBoYW5kbGVkRm9vdGVyTWVzc2FnZUlEOiAwLAoKCiAgICAgICAgfTsKICAgIH0sCiAgICBtb3VudGVkKCkgewoKICAgICAgICB0aGlzLmluaXQoKTsKCiAgICB9LAogICAgbWV0aG9kczogewogICAgICAgIGluaXQoKSB7CgogICAgICAgICAgICBjb25zdCBkYWcgPSB0aGlzLiRyZWZzLmRpc3RyaWJ1dGlvbk1haW47CiAgICAgICAgICAgIHRoaXMuc3ZnRnVsbFNpemUuaGVpZ2h0ID0gZGFnLmNsaWVudEhlaWdodDsKICAgICAgICAgICAgdGhpcy5zdmdGdWxsU2l6ZS53aWR0aCA9IGRhZy5jbGllbnRXaWR0aDsKCgogICAgICAgICAgICB0aGlzLmNvbXBvbmVudCA9IGQzLnNlbGVjdCgnLmRpc3RyaWJ1dGlvbi1tYWluJyk7CiAgICAgICAgICAgIHRoaXMuc2hvd0dyaWQgPSB0cnVlOwoKCiAgICAgICAgICAgIHRoaXMuaW5pdFdvcmtlcigpOwoKICAgICAgICAgICAgdGhpcy5pbml0VG9wU3ZnKCk7CiAgICAgICAgICAgIC8vIEluaXRpYWxpemUgdGhlIGNhbnZhc2VzCiAgICAgICAgICAgIHRoaXMuaW5pdENhbnZhcygpOwogICAgICAgICAgICAvLyAKICAgICAgICAgICAgdGhpcy5pbml0U1ZHR3JvdXBzKCk7CgogICAgICAgICAgICB0aGlzLmluaXREYXRhKCkudGhlbigoKSA9PiB7CgogICAgICAgICAgICAgICAgaW5pdFdlYkdMTWF0cmljZXModGhpcyk7IC8vIOehruS/nSB0aGlzIOaMh+WQkSBWdWUg5a6e5L6LCgogICAgICAgICAgICAgICAgaW5pdFdlYkdMQnVmZmVycyh0aGlzKTsKCiAgICAgICAgICAgICAgICBkcmF3U2NhdHRlclBsb3QodGhpcyk7CgogICAgICAgICAgICAgICAgZGlzcGxheUdyb3VwQ2hhbmdlZCh0aGlzLCAiSW1hZ2UiKQoKICAgICAgICAgICAgICAgIC8vIFBvaW50RHJhd2VyLmRyYXdHcm91cENvbnRvdXIodGhpcyk7CgogICAgICAgICAgICAgICAgdGhpcy50b3BpY0NhbnZhc2VzLmZvckVhY2goYyA9PiBjLmNsYXNzZWQoJ2hpZGRlbicsICF0aGlzLnNob3dHcmlkKSk7CiAgICAgICAgICAgICAgICB0aGlzLnNob3dQb2ludHMgPSBbdHJ1ZV07CiAgICAgICAgICAgICAgICByZWRyYXdUb3BpY0dyaWQodGhpcywgbnVsbCk7CiAgICAgICAgICAgIH0pOwoKICAgICAgICAgICAgLy8gUmVnaXN0ZXIgem9vbQogICAgICAgICAgICB0aGlzLnpvb20gPSBkMwogICAgICAgICAgICAgICAgLnpvb20oKQogICAgICAgICAgICAgICAgLmV4dGVudChbCiAgICAgICAgICAgICAgICAgICAgWzAsIDBdLAogICAgICAgICAgICAgICAgICAgIFt0aGlzLnN2Z1NpemUud2lkdGgsIHRoaXMuc3ZnU2l6ZS5oZWlnaHRdCiAgICAgICAgICAgICAgICBdKQogICAgICAgICAgICAgICAgLnNjYWxlRXh0ZW50KFtjb25maWcubGF5b3V0Lnpvb21TY2FsZVswXSwgY29uZmlnLmxheW91dC56b29tU2NhbGVbMV1dKQogICAgICAgICAgICAgICAgLmludGVycG9sYXRlKGQzLmludGVycG9sYXRlKQogICAgICAgICAgICAgICAgLm9uKCd6b29tJywgKGcpID0+IHsKICAgICAgICAgICAgICAgICAgICAoYXN5bmMgKCkgPT4gewogICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnpvb21lZChnKTsKICAgICAgICAgICAgICAgICAgICB9KSgpOwogICAgICAgICAgICAgICAgfSkKICAgICAgICAgICAgICAgIC5vbignZW5kJywgKCkgPT4gdGhpcy56b29tRW5kZWQoKSk7CgogICAgICAgICAgICB0aGlzLnRvcFN2Zy5jYWxsKHRoaXMuem9vbSkub24oJ2RibGNsaWNrLnpvb20nLCBudWxsKTsKCiAgICAgICAgICAgIHRoaXMudG9vbHRpcFRvcCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNwb3BwZXItdG9vbHRpcC10b3AnKTsKICAgICAgICAgICAgdGhpcy50b29sdGlwQm90dG9tID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3BvcHBlci10b29sdGlwLWJvdHRvbScpOwoKICAgICAgICAgICAgY29uc3Qgc3F1YXJlQ2FudmFzV2lkdGggPSBNYXRoLm1pbigKICAgICAgICAgICAgICAgIHRoaXMuc3ZnRnVsbFNpemUud2lkdGggLSB0aGlzLnN2Z1BhZGRpbmcubGVmdCAtIHRoaXMuc3ZnUGFkZGluZy5yaWdodCwKICAgICAgICAgICAgICAgIHRoaXMuc3ZnRnVsbFNpemUuaGVpZ2h0IC0gdGhpcy5zdmdQYWRkaW5nLnRvcCAtIHRoaXMuc3ZnUGFkZGluZy5ib3R0b20KICAgICAgICAgICAgKTsKCiAgICAgICAgICAgIHRoaXMuc3ZnU2l6ZSA9IHsKICAgICAgICAgICAgICAgIHdpZHRoOiBzcXVhcmVDYW52YXNXaWR0aCwKICAgICAgICAgICAgICAgIGhlaWdodDogc3F1YXJlQ2FudmFzV2lkdGgKICAgICAgICAgICAgfTsKCgogICAgICAgICAgICB0aGlzLmN1clpvb21UcmFuc2Zvcm0gPSBkMy56b29tSWRlbnRpdHk7CgogICAgICAgIH0sCiAgICAgICAgYXN5bmMgaW5pdERhdGEoKSB7CgogICAgICAgICAgICBjb25zdCBncmlkRGF0YSA9IGF3YWl0IGQzLmpzb24odGhpcy4kc3RvcmUuc3RhdGUuZGF0YVVSTHMuZ3JpZCk7CiAgICAgICAgICAgIGlmIChncmlkRGF0YSA9PT0gdW5kZWZpbmVkKSB7CiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnRmFpbCB0byBsb2FkIGdyaWQgZGF0YScpOwogICAgICAgICAgICB9CgogICAgICAgICAgICB0aGlzLmdyaWREYXRhID0gZ3JpZERhdGE7CgogICAgICAgICAgICAvLyBJbml0aWFsaXplIHRoZSBkYXRhIHNjYWxlcwogICAgICAgICAgICBjb25zdCB4UmFuZ2UgPSB0aGlzLmdyaWREYXRhLnhSYW5nZTsKICAgICAgICAgICAgY29uc3QgeVJhbmdlID0gdGhpcy5ncmlkRGF0YS55UmFuZ2U7CgogICAgICAgICAgICBsZXQgeExlbmd0aCA9IHhSYW5nZVsxXSAtIHhSYW5nZVswXTsKICAgICAgICAgICAgbGV0IHlMZW5ndGggPSB5UmFuZ2VbMV0gLSB5UmFuZ2VbMF07CgogICAgICAgICAgICBpZiAoIXRoaXMuZ3JpZERhdGEucGFkZGVkKSB7CiAgICAgICAgICAgICAgICAvLyBBZGQgcGFkZGluZyBmb3IgdGhlIGRhdGEKICAgICAgICAgICAgICAgIGlmICh4TGVuZ3RoIDwgeUxlbmd0aCkgewogICAgICAgICAgICAgICAgICAgIHlSYW5nZVswXSAtPSB5TGVuZ3RoIC8gNTA7CiAgICAgICAgICAgICAgICAgICAgeVJhbmdlWzFdICs9IHlMZW5ndGggLyA1MDsKICAgICAgICAgICAgICAgICAgICB5TGVuZ3RoID0geVJhbmdlWzFdIC0geVJhbmdlWzBdOwoKICAgICAgICAgICAgICAgICAgICB4UmFuZ2VbMF0gLT0gKHlMZW5ndGggLSB4TGVuZ3RoKSAvIDI7CiAgICAgICAgICAgICAgICAgICAgeFJhbmdlWzFdICs9ICh5TGVuZ3RoIC0geExlbmd0aCkgLyAyOwogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAvLyBBZGQgcGFkZGluZyBmb3IgdGhlIGRhdGEKICAgICAgICAgICAgICAgICAgICB4UmFuZ2VbMF0gLT0geExlbmd0aCAvIDUwOwogICAgICAgICAgICAgICAgICAgIHhSYW5nZVsxXSArPSB4TGVuZ3RoIC8gNTA7CiAgICAgICAgICAgICAgICAgICAgeExlbmd0aCA9IHhSYW5nZVsxXSAtIHhSYW5nZVswXTsKCiAgICAgICAgICAgICAgICAgICAgeVJhbmdlWzBdIC09ICh4TGVuZ3RoIC0geUxlbmd0aCkgLyAyOwogICAgICAgICAgICAgICAgICAgIHlSYW5nZVsxXSArPSAoeExlbmd0aCAtIHlMZW5ndGgpIC8gMjsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICB0aGlzLnhTY2FsZSA9IGQzCiAgICAgICAgICAgICAgICAuc2NhbGVMaW5lYXIoKQogICAgICAgICAgICAgICAgLmRvbWFpbih4UmFuZ2UpCiAgICAgICAgICAgICAgICAucmFuZ2UoWzAsIHRoaXMuc3ZnU2l6ZS53aWR0aF0pOwoKICAgICAgICAgICAgdGhpcy55U2NhbGUgPSBkMwogICAgICAgICAgICAgICAgLnNjYWxlTGluZWFyKCkKICAgICAgICAgICAgICAgIC5kb21haW4oeVJhbmdlKQogICAgICAgICAgICAgICAgLnJhbmdlKFt0aGlzLnN2Z1NpemUuaGVpZ2h0LCAwXSk7CgogICAgICAgICAgICAvLyBQb2ludERyYXdlci5kcmF3R3JvdXBDb250b3VyKHRoaXMpOwoKCiAgICAgICAgICAgIC8vIENyZWF0ZSBncm91cCByZWxhdGVkIHN0cnVjdHVyZXMgaWYgdGhlIGRhdGEgaGFzIGdyb3VwcwogICAgICAgICAgICBpZiAodGhpcy5ncmlkRGF0YS5ncm91cEdyaWRzICYmIHRoaXMuZ3JpZERhdGEuZ3JvdXBOYW1lcykgewogICAgICAgICAgICAgICAgdGhpcy5ncm91cE5hbWVzID0gdGhpcy5ncmlkRGF0YS5ncm91cE5hbWVzOwogICAgICAgICAgICAgICAgY29uc3QgdW1hcEdyb3VwID0gdGhpcy5zdmcuc2VsZWN0KCdnLnVtYXAtZ3JvdXAnKTsKCiAgICAgICAgICAgICAgICAvLyBBZGp1c3QgdGhlIGZpcnN0IGNvbnRvdXIncyBuYW1lCiAgICAgICAgICAgICAgICB0aGlzLnNob3dDb250b3VycyA9IFtdOwogICAgICAgICAgICAgICAgdGhpcy5zaG93UG9pbnRzID0gW107CiAgICAgICAgICAgICAgICB0aGlzLmdyb3VwQ29udG91cnMgPSBbXTsKCiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZ3JvdXBOYW1lcy5sZW5ndGg7IGkrKykgewogICAgICAgICAgICAgICAgICAgIC8vIEFkZCBncm91cHMgdG8gdGhlIGNvbnRyb2wgc3RhdGVzCiAgICAgICAgICAgICAgICAgICAgLy8gKERlZmF1bHQgaXMgdG8gc2hvdyB0aGUgZmlyc3QgZ3JvdXAgb25seSkKICAgICAgICAgICAgICAgICAgICB0aGlzLnNob3dDb250b3Vycy5wdXNoKGkgPT09IDApOwogICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvd1BvaW50cy5wdXNoKGkgPT09IDApOwoKICAgICAgICAgICAgICAgICAgICAvLyBBZGQgY29udG91ciBlbGVtZW50cyBmb3Igb3RoZXIgZ3JvdXBzCiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMuZ3JvdXBOYW1lc1tpXTsKICAgICAgICAgICAgICAgICAgICB1bWFwR3JvdXAKICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgnZycpCiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIGBjb250b3VyLWdyb3VwLWdlbmVyaWMgY29udG91ci1ncm91cC0ke25hbWV9YCkKICAgICAgICAgICAgICAgICAgICAgICAgLmNsYXNzZWQoJ2hpZGRlbicsIGkgIT09IDApOwoKICAgICAgICAgICAgICAgICAgICAvLyBEcncgdGhlIGdyb3VwIGNvbnRvdXIKICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJDb250b3VyID0gZHJhd0dyb3VwQ29udG91cih0aGlzLCBuYW1lKTsKICAgICAgICAgICAgICAgICAgICBpZiAoY3VyQ29udG91ciAhPT0gbnVsbCkgewogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdyb3VwQ29udG91cnMucHVzaChjdXJDb250b3VyKTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIC8vIFRlbGwgdGhlIHRyZWUgd29ya2VyIHRvIHByZXBhcmUgdG8gYWRkIHBvaW50cyB0byB0aGUgdHJlZQogICAgICAgICAgICBjb25zdCBncm91cElEcyA9IFtdOwoKICAgICAgICAgICAgaWYgKHRoaXMuZ3JvdXBOYW1lcykgewogICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmdyb3VwTmFtZXMubGVuZ3RoOyBpKyspIHsKICAgICAgICAgICAgICAgICAgICBncm91cElEcy5wdXNoKGkpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CgogICAgICAgICAgICBjb25zdCB0cmVlTWVzc2FnZSA9IHsKICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICdpbml0UXVhZHRyZWUnLAogICAgICAgICAgICAgICAgcGF5bG9hZDogewogICAgICAgICAgICAgICAgICAgIHhSYW5nZTogeFJhbmdlLAogICAgICAgICAgICAgICAgICAgIHlSYW5nZTogeVJhbmdlLAogICAgICAgICAgICAgICAgICAgIGdyb3VwSURzOiBncm91cElEcywKICAgICAgICAgICAgICAgICAgICB0aW1lczogWycnXQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9OwoKICAgICAgICAgICAgY29uc29sZS5sb2coInRyZWVNZXNzYWdlIiwgZ3JvdXBJRHMpCiAgICAgICAgICAgIHRoaXMudHJlZVdvcmtlci5wb3N0TWVzc2FnZSh0cmVlTWVzc2FnZSk7CgogICAgICAgICAgICBmb3IgKGNvbnN0IGxldmVsIG9mIE9iamVjdC5rZXlzKHRoaXMuZ3JpZERhdGEudG9waWMuZGF0YSkpIHsKICAgICAgICAgICAgICAgIGNvbnN0IHRyZWUgPSBkMwogICAgICAgICAgICAgICAgICAgIC5xdWFkdHJlZSgpCiAgICAgICAgICAgICAgICAgICAgLngoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRbMF07IH0pCiAgICAgICAgICAgICAgICAgICAgLnkoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRbMV07IH0pCiAgICAgICAgICAgICAgICAgICAgLmFkZEFsbCh0aGlzLmdyaWREYXRhLnRvcGljLmRhdGFbbGV2ZWxdKTsKICAgICAgICAgICAgICAgIHRoaXMudG9waWNMZXZlbFRyZWVzLnNldChwYXJzZUludChsZXZlbCwgMTApLCB0cmVlKTsKICAgICAgICAgICAgfQoKCgoKICAgICAgICB9LAogICAgICAgIGluaXRDYW52YXMoKSB7CgogICAgICAgICAgICBjb25zdCBkaXNjb21wb25lbnQgPSB0aGlzLiRyZWZzLmRpc3RyaWJ1dGlvbk1haW47CiAgICAgICAgICAgIHRoaXMucG9pbnRDYW52YXMgPSBkMy5zZWxlY3QoZGlzY29tcG9uZW50KQogICAgICAgICAgICAgICAgLmFwcGVuZCgnY2FudmFzJykKICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbWJlZGRpbmctY2FudmFzJykKICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIHRoaXMuc3ZnRnVsbFNpemUud2lkdGgpCiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgdGhpcy5zdmdGdWxsU2l6ZS5oZWlnaHQpOwoKICAgICAgICAgICAgdGhpcy5wb2ludFJlZ2wgPSBjcmVhdGVSZWdsKHRoaXMucG9pbnRDYW52YXM/Lm5vZGUoKSk7CgogICAgICAgICAgICAvLyB0aGlzLnNlYXJjaFBvaW50Q2FudmFzID0gZDMuc2VsZWN0KGRpc2NvbXBvbmVudCkKICAgICAgICAgICAgLy8gICAgIC5hcHBlbmQoJ2NhbnZhcycpCiAgICAgICAgICAgIC8vICAgICAuYXR0cignY2xhc3MnLCAnc2VhcmNoLXBvaW50LWNhbnZhcycpCiAgICAgICAgICAgIC8vICAgICAuYXR0cignd2lkdGgnLCB0aGlzLnN2Z0Z1bGxTaXplLndpZHRoKQogICAgICAgICAgICAvLyAgICAgLmF0dHIoJ2hlaWdodCcsIHRoaXMuc3ZnRnVsbFNpemUuaGVpZ2h0KTsKCiAgICAgICAgICAgIC8vIHRoaXMuc2VhcmNoUG9pbnRSZWdsID0gY3JlYXRlUmVnbCh0aGlzLnNlYXJjaFBvaW50Q2FudmFzPy5ub2RlKCkpOwoKICAgICAgICAgICAgdGhpcy50b3BpY0NhbnZhc2VzID0gW107CiAgICAgICAgICAgIGZvciAoY29uc3QgcG9zIG9mIFsndG9wJywgJ2JvdHRvbSddKSB7CiAgICAgICAgICAgICAgICB0aGlzLnRvcGljQ2FudmFzZXMucHVzaCgKICAgICAgICAgICAgICAgICAgICBkMwogICAgICAgICAgICAgICAgICAgICAgICAuc2VsZWN0KGRpc2NvbXBvbmVudCkKICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgnY2FudmFzJykKICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgYHRvcGljLWdyaWQtY2FudmFzICR7cG9zfWApCiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIGAke3RoaXMuc3ZnRnVsbFNpemUud2lkdGh9cHhgKQogICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgYCR7dGhpcy5zdmdGdWxsU2l6ZS5oZWlnaHR9cHhgKQogICAgICAgICAgICAgICAgICAgICAgICAuY2xhc3NlZCgnaGlkZGVuJywgIXRoaXMuc2hvd0dyaWQpCiAgICAgICAgICAgICAgICApOwogICAgICAgICAgICB9CgogICAgICAgIH0sCiAgICAgICAgaW5pdFNWR0dyb3VwcygpIHsKCiAgICAgICAgICAgIHRoaXMuc3ZnID0gdGhpcy5jb21wb25lbnQuYXBwZW5kKCdzdmcnKQogICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgImVtYmVkZGluZy1zdmciKQogICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgdGhpcy5zdmdGdWxsU2l6ZS53aWR0aCkKICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCB0aGlzLnN2Z0Z1bGxTaXplLmhlaWdodCk7CgoKICAgICAgICAgICAgY29uc3QgdW1hcEdyb3VwID0gdGhpcy5zdmcKICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2cnKQogICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3VtYXAtZ3JvdXAnKQogICAgICAgICAgICAgICAgLmF0dHIoCiAgICAgICAgICAgICAgICAgICAgJ3RyYW5zZm9ybScsCiAgICAgICAgICAgICAgICAgICAgYHRyYW5zbGF0ZSgke3RoaXMuc3ZnUGFkZGluZy5sZWZ0fSwgJHt0aGlzLnN2Z1BhZGRpbmcudG9wfSlgCiAgICAgICAgICAgICAgICApOwoKICAgICAgICAgICAgdW1hcEdyb3VwCiAgICAgICAgICAgICAgICAuYXBwZW5kKCdnJykKICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdjb250b3VyLWdyb3VwJykKICAgICAgICAgICAgICAgIC5jbGFzc2VkKCdoaWRkZW4nLCAhdGhpcy5zaG93Q29udG91cnMpOwoKICAgICAgICB9LAogICAgICAgIGluaXRUb3BTdmcoKSB7CgogICAgICAgICAgICAvLyDliJvlu7rkuIDkuKogU1ZHIOWFg+e0oOW5tuiuvue9ruWFtuWxnuaApwogICAgICAgICAgICB0aGlzLnRvcFN2ZyA9IHRoaXMuY29tcG9uZW50LmFwcGVuZCgnc3ZnJykKICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICJ0b3Atc3ZnIikKICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIGAke3RoaXMuc3ZnRnVsbFNpemUud2lkdGh9cHhgKQogICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGAke3RoaXMuc3ZnRnVsbFNpemUuaGVpZ2h0fXB4YCkgLy8g6K6+572u6auY5bqmCiAgICAgICAgICAgICAgICAub24oJ3BvaW50ZXJtb3ZlJywgZSA9PiB0aGlzLm1vdXNlbW92ZUhhbmRsZXIoZSkpCiAgICAgICAgICAgICAgICAub24oJ21vdXNlbGVhdmUnLCAoKSA9PiB7CiAgICAgICAgICAgICAgICAgICAgaGlnaGxpZ2h0UG9pbnQodGhpcywgeyBwb2ludDogdW5kZWZpbmVkLCBhbmltYXRlZDogZmFsc2UgfSk7CiAgICAgICAgICAgICAgICAgICAgbW91c2VvdmVyTGFiZWwodGhpcywgbnVsbCwgbnVsbCk7CiAgICAgICAgICAgICAgICB9KQogICAgICAgICAgICAgICAgLmF0dHIoCiAgICAgICAgICAgICAgICAgICAgJ3RyYW5zZm9ybScsCiAgICAgICAgICAgICAgICAgICAgYHRyYW5zbGF0ZSgke3RoaXMuc3ZnUGFkZGluZy5sZWZ0fSwgJHt0aGlzLnN2Z1BhZGRpbmcudG9wfSlgCiAgICAgICAgICAgICAgICApOwoKCiAgICAgICAgICAgIGNvbnN0IHRvcEdyb3VwID0gdGhpcy50b3BTdmcuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAndG9wLWdyb3VwJyk7CgogICAgICAgICAgICB0b3BHcm91cAogICAgICAgICAgICAgICAgLmFwcGVuZCgncmVjdCcpCiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbW91c2UtdHJhY2stcmVjdCcpCiAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCB0aGlzLnN2Z0Z1bGxTaXplLndpZHRoKQogICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIHRoaXMuc3ZnRnVsbFNpemUuaGVpZ2h0KTsKCiAgICAgICAgICAgIGNvbnN0IHRvcENvbnRlbnQgPSB0b3BHcm91cC5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICd0b3AtY29udGVudCcpOwoKICAgICAgICAgICAgdG9wQ29udGVudC5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICd0b3BpY3MtYm90dG9tJyk7CiAgICAgICAgICAgIHRvcENvbnRlbnQKICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2cnKQogICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3RvcGljcycpCiAgICAgICAgICAgICAgICAuY2xhc3NlZCgnaGlkZGVuJywgIXRoaXMuc2hvd0xhYmVsKTsKICAgICAgICAgICAgdG9wQ29udGVudC5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICd0b3BpY3MtdG9wJyk7CiAgICAgICAgICAgIHRvcENvbnRlbnQuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnaGlnaGxpZ2h0cycpOwoKCgogICAgICAgIH0sCiAgICAgICAgem9vbWVkKGUpIHsKCiAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGUudHJhbnNmb3JtOwogICAgICAgICAgICBjb25zdCBzY2FsZUNoYW5nZWQgPSB0aGlzLmN1clpvb21UcmFuc2Zvcm0uayAhPT0gdHJhbnNmb3JtLms7CiAgICAgICAgICAgIHRoaXMuY3VyWm9vbVRyYW5zZm9ybSA9IHRyYW5zZm9ybTsKCiAgICAgICAgICAgIC8vID09PSBUYXNrICgxKSA9PT0KICAgICAgICAgICAgLy8gVHJhbnNmb3JtIHRoZSBTVkcgZWxlbWVudHMKICAgICAgICAgICAgdGhpcy5zdmcuc2VsZWN0KCcudW1hcC1ncm91cCcpLmF0dHIoJ3RyYW5zZm9ybScsIHRyYW5zZm9ybS50b1N0cmluZygpKTsKCiAgICAgICAgICAgIC8vIFRyYW5zZm9ybSB0aGUgdG9wIFNWRyBlbGVtZW50cwogICAgICAgICAgICB0aGlzLnRvcFN2ZwogICAgICAgICAgICAgICAgLnNlbGVjdCgnLnRvcC1ncm91cCcpCiAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgdHJhbnNmb3JtLnRvU3RyaW5nKCkpOwoKICAgICAgICAgICAgLy8gVHJhbnNmb3JtIHRoZSB2aXNpYmxlIGNhbnZhcyBlbGVtZW50cwogICAgICAgICAgICBpZiAoYW55VHJ1ZSh0aGlzLnNob3dQb2ludHMpKSB7CiAgICAgICAgICAgICAgICBpZiAodGhpcy5mcm9udFBvc2l0aW9uQnVmZmVyICYmIHRoaXMuZnJvbnRUZXh0dXJlQ29vcmRpbmF0ZUJ1ZmZlcikgewogICAgICAgICAgICAgICAgICAgIGRyYXdTY2F0dGVyUGxvdCh0aGlzKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQoKICAgICAgICAgICAgaWYgKHRoaXMuc2hvd0dyaWQpIHsKICAgICAgICAgICAgICAgIHJlZHJhd1RvcGljR3JpZCh0aGlzLCBudWxsKTsKICAgICAgICAgICAgfQoKCgogICAgICAgIH0sCiAgICAgICAgLy8gRXZlbnQgaGFuZGxlciBmb3Igem9vbSBlbmRlZAogICAgICAgIHpvb21FbmRlZCgpIHsKICAgICAgICAgICAgY29uc29sZS5sb2coInN2ZyB6b29tIGVuZCAhISEiKQogICAgICAgIH0sCiAgICAgICAgaW5pdFdvcmtlcigpIHsKICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgd2ViIHdvcmtlciB0byBsb2FkIGRhdGEgYW5kIGRlYWwgd2l0aCB0aGUgcXVhZHRyZWUKICAgICAgICAgICAgdGhpcy5sb2FkZXJXb3JrZXIgPSBuZXcgTG9hZGVyV29ya2VyKCk7CiAgICAgICAgICAgIGNvbnNvbGUubG9nKCJMb2FkZXJXb3JrZXIiLCBMb2FkZXJXb3JrZXIpCiAgICAgICAgICAgIHRoaXMubG9hZGVyV29ya2VyLm9ubWVzc2FnZSA9IChlKSA9PiB7CiAgICAgICAgICAgICAgICB0aGlzLmxvYWRlcldvcmtlck1lc3NhZ2VIYW5kbGVyKGUpOwogICAgICAgICAgICB9OwoKICAgICAgICAgICAgdGhpcy50cmVlV29ya2VyID0gbmV3IFRyZWVXb3JrZXIoKTsKICAgICAgICAgICAgY29uc29sZS5sb2coInRyZWVXb3JrZXIiLCB0aGlzLnRyZWVXb3JrZXIpCiAgICAgICAgICAgIHRoaXMudHJlZVdvcmtlci5vbm1lc3NhZ2UgPSAoZSkgPT4gewogICAgICAgICAgICAgICAgdGhpcy50cmVlV29ya2VyTWVzc2FnZUhhbmRsZXIoZSk7CiAgICAgICAgICAgIH07CiAgICAgICAgfSwKICAgICAgICBsb2FkZXJXb3JrZXJNZXNzYWdlSGFuZGxlcihlKSB7CiAgICAgICAgICAgIHN3aXRjaCAoZS5kYXRhLmNvbW1hbmQpIHsKICAgICAgICAgICAgICAgIGNhc2UgJ3RyYW5zZmVyTG9hZERhdGEnOiB7CiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRoZXNlIHBvaW50cyB0byB0aGUgcXVhZHRyZWUgQVNBUAogICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyZWVNZXNzYWdlID0gewogICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kOiAndXBkYXRlUXVhZHRyZWUnLAogICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludHM6IGUuZGF0YS5wYXlsb2FkLnBvaW50cwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgfTsKICAgICAgICAgICAgICAgICAgICB0aGlzLnRyZWVXb3JrZXIucG9zdE1lc3NhZ2UodHJlZU1lc3NhZ2UpOwoKICAgICAgICAgICAgICAgICAgICBpZiAoZS5kYXRhLnBheWxvYWQuaXNGaXJzdEJhdGNoKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgZmlyc3QgYmF0Y2ggcG9pbnRzCiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvbXB0UG9pbnRzID0gZS5kYXRhLnBheWxvYWQucG9pbnRzOwoKICAgICAgICAgICAgICAgICAgICAgICAgaW5pdFdlYkdMQnVmZmVycyh0aGlzKTsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFueVRydWUodGhpcy5zaG93UG9pbnRzKSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJhd1NjYXR0ZXJQbG90KHRoaXMpOwogICAgICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIHBvaW50cyB0byB0aGUgc2VhcmNoIGluZGV4CiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlYXJjaE1lc3NhZ2UgPSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kOiAnYWRkUG9pbnRzJywKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludHM6IGUuZGF0YS5wYXlsb2FkLnBvaW50cwogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICB9OwogICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzLnNlYXJjaFdvcmtlci5wb3N0TWVzc2FnZShzZWFyY2hNZXNzYWdlKTsKICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAvLyBCYXRjaGVzIGFmdGVyIHRoZSBmaXJzdCBiYXRjaAogICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIHBvaW50cyB0byB0aGUgcHJvbXB0IHBvaW50IGxpc3QKICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3UG9pbnRzID0gZS5kYXRhLnBheWxvYWQucG9pbnRzOwogICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBvaW50IG9mIG5ld1BvaW50cykgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9tcHRQb2ludHMucHVzaChwb2ludCk7CiAgICAgICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgcG9pbnRzIHRvIHRoZSBzZWFyY2ggaW5kZXgKICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc3Qgc2VhcmNoTWVzc2FnZSA9IHsKICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgIGNvbW1hbmQ6ICdhZGRQb2ludHMnLAogICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgcGF5bG9hZDogewogICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgIHBvaW50czogbmV3UG9pbnRzCiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIC8vIH07CiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMuc2VhcmNoV29ya2VyLnBvc3RNZXNzYWdlKHNlYXJjaE1lc3NhZ2UpOwoKICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBuZXcgcG9pbnRzIHRvIHRoZSBXZWJHTCBidWZmZXJzCiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVdlYkdMQnVmZmVycyh0aGlzLCBuZXdQb2ludHMpOwogICAgICAgICAgICAgICAgICAgICAgICBpZiAoYW55VHJ1ZSh0aGlzLnNob3dQb2ludHMpKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkcmF3U2NhdHRlclBsb3QodGhpcyk7CiAgICAgICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLmRhdGEucGF5bG9hZC5pc0xhc3RCYXRjaCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0ZpbmlzaGVkIGxvYWRpbmcgYWxsIGRhdGEuJyk7CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgZGF0YSBwb2ludCBjb3VudAogICAgICAgICAgICAgICAgICAgIHRoaXMubG9hZGVkUG9pbnRDb3VudCA9IGUuZGF0YS5wYXlsb2FkLmxvYWRlZFBvaW50Q291bnQ7CgogICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgZm9vdGVyCiAgICAgICAgICAgICAgICAgICAgdGhpcy5mb290ZXJTdG9yZVZhbHVlLm51bVBvaW50cyA9IHRoaXMucHJvbXB0UG9pbnRzLmxlbmd0aDsKICAgICAgICAgICAgICAgICAgICAvLyB0aGlzLmZvb3RlclN0b3JlLnNldCh0aGlzLmZvb3RlclN0b3JlVmFsdWUpOwogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHsKICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdVbmtub3duIG1lc3NhZ2UnLCBlLmRhdGEuY29tbWFuZCk7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICB9LAogICAgICAgIHRyZWVXb3JrZXJNZXNzYWdlSGFuZGxlcihlKSB7CiAgICAgICAgICAgIHN3aXRjaCAoZS5kYXRhLmNvbW1hbmQpIHsKICAgICAgICAgICAgICAgIGNhc2UgJ2ZpbmlzaEluaXRRdWFkdHJlZSc6IHsKICAgICAgICAgICAgICAgICAgICAvLyBUZWxsIHRoZSBsb2FkZXIgd29ya2VyIHRvIHN0YXJ0IGxvYWRpbmcgZGF0YQogICAgICAgICAgICAgICAgICAgIC8vIChuZWVkIHRvIHdhaXQgdG8gc2V0IHVwIHRoZSBxdWFkdHJlZSB0byBhdm9pZCByYWNpbmcpCiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IHsKICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZDogJ3N0YXJ0TG9hZERhdGEnLAogICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkOiB7IHVybDogdGhpcy4kc3RvcmUuc3RhdGUuZGF0YVVSTHMucG9pbnQgfQogICAgICAgICAgICAgICAgICAgIH07CiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2FkZXJXb3JrZXIucG9zdE1lc3NhZ2UobWVzc2FnZSk7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgY2FzZSAnZmluaXNoUXVhZHRyZWVTZWFyY2gnOiB7CiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubGFzdE1vdXNlQ2xpZW50UG9zaXRpb24gPT09IG51bGwpIHsKICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdsYXN0TW91c2VDbGllbnRQb3NpdGlvbiBpcyBudWxsJyk7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBjbG9zZXN0IHBvaW50IGlzIHJlbGF0aXZlbHkgY2xvc2UgdG8gdGhlIG1vdXNlCiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2xvc2VzdFBvaW50ID0gc3RydWN0dXJlZENsb25lKAogICAgICAgICAgICAgICAgICAgICAgICBlLmRhdGEucGF5bG9hZC5wb2ludAogICAgICAgICAgICAgICAgICAgICk7CiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2NyZWVuUG9pbnRYID0gdGhpcy5jdXJab29tVHJhbnNmb3JtLmFwcGx5WCgKICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy54U2NhbGUoY2xvc2VzdFBvaW50LngpCiAgICAgICAgICAgICAgICAgICAgKTsKICAgICAgICAgICAgICAgICAgICBjb25zdCBzY3JlZW5Qb2ludFkgPSB0aGlzLmN1clpvb21UcmFuc2Zvcm0uYXBwbHlZKAogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnlTY2FsZShjbG9zZXN0UG9pbnQueSkKICAgICAgICAgICAgICAgICAgICApOwoKICAgICAgICAgICAgICAgICAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGgubWF4KAogICAgICAgICAgICAgICAgICAgICAgICBNYXRoLmFicyhzY3JlZW5Qb2ludFggLSB0aGlzLmxhc3RNb3VzZUNsaWVudFBvc2l0aW9uLngpLAogICAgICAgICAgICAgICAgICAgICAgICBNYXRoLmFicyhzY3JlZW5Qb2ludFkgLSB0aGlzLmxhc3RNb3VzZUNsaWVudFBvc2l0aW9uLnkpCiAgICAgICAgICAgICAgICAgICAgKTsKCiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGlnaGxpZ2h0UmFkaXVzID0gTWF0aC5tYXgoCiAgICAgICAgICAgICAgICAgICAgICAgIDEwIC8gdGhpcy5jdXJab29tVHJhbnNmb3JtLmssCiAgICAgICAgICAgICAgICAgICAgICAgIChjb25maWcubGF5b3V0LnNjYXR0ZXJEb3RSYWRpdXMgKgogICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5leHAoTWF0aC5sb2codGhpcy5jdXJab29tVHJhbnNmb3JtLmspICogMC41NSkpIC8KICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJab29tVHJhbnNmb3JtLmsKICAgICAgICAgICAgICAgICAgICApOwoKICAgICAgICAgICAgICAgICAgICAvLyBIaWdobGlnaHQgdGhlIHBvaW50IGlmIGl0IGlzIGNsb3NlIGVub3VnaCB0byB0aGUgbW91c2UKICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJIb3ZlclJhZGl1cyA9IE1hdGgubWF4KAogICAgICAgICAgICAgICAgICAgICAgICBIT1ZFUl9SQURJVVMsCiAgICAgICAgICAgICAgICAgICAgICAgIGhpZ2hsaWdodFJhZGl1cyAqIHRoaXMuY3VyWm9vbVRyYW5zZm9ybS5rCiAgICAgICAgICAgICAgICAgICAgKTsKCiAgICAgICAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlIDw9IGN1ckhvdmVyUmFkaXVzKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGhpZ2hsaWdodFBvaW50KHRoaXMsIHsgcG9pbnQ6IGNsb3Nlc3RQb2ludCwgYW5pbWF0ZWQ6IGZhbHNlIH0pOwogICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGhpZ2hsaWdodFBvaW50KHRoaXMsIHsgcG9pbnQ6IHVuZGVmaW5lZCwgYW5pbWF0ZWQ6IGZhbHNlIH0pOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICBkZWZhdWx0OiB7CiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignVW5rbm93biBtZXNzYWdlJywgZS5kYXRhLmNvbW1hbmQpOwogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgfSwKCiAgICAgICAgbW91c2VvdmVyUG9pbnQoeCwgeSkgewogICAgICAgICAgICAvLyBJbnZlcnQgdG8gdGhlIHN0YWdlIHNjYWxlID0+IGludmVydCB0byB0aGUgZGF0YSBzY2FsZQogICAgICAgICAgICBjb25zdCBkYXRhWCA9IHRoaXMueFNjYWxlLmludmVydCh0aGlzLmN1clpvb21UcmFuc2Zvcm0uaW52ZXJ0WCh4KSk7CiAgICAgICAgICAgIGNvbnN0IGRhdGFZID0gdGhpcy55U2NhbGUuaW52ZXJ0KHRoaXMuY3VyWm9vbVRyYW5zZm9ybS5pbnZlcnRZKHkpKTsKCiAgICAgICAgICAgIC8vIExldCB0aGUgd29ya2VyIHRvIHNlYXJjaCB0aGUgY2xvc2VzdCBwb2ludCBpbiBhIHJhZGl1cwogICAgICAgICAgICBsZXQgZ3JvdXBJRCA9IC0xOwoKICAgICAgICAgICAgaWYgKHRoaXMuZ3JvdXBOYW1lcykgewogICAgICAgICAgICAgICAgaWYgKGFsbFRydWUodGhpcy5zaG93UG9pbnRzKSkgewogICAgICAgICAgICAgICAgICAgIGdyb3VwSUQgPSAtMTsKICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogTmVlZCBhIGJldHRlciB3YXkgdG8gc2VhcmNoIHNsaWNlcyBvZiBncm91cHMgZm9yIG11bHRpIGdyb3VwcwogICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zaG93UG9pbnRzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNob3dQb2ludHNbaV0pIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwSUQgPSBpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB7CiAgICAgICAgICAgICAgICBjb21tYW5kOiAnc3RhcnRRdWFkdHJlZVNlYXJjaCcsCiAgICAgICAgICAgICAgICBwYXlsb2FkOiB7CiAgICAgICAgICAgICAgICAgICAgeDogZGF0YVgsCiAgICAgICAgICAgICAgICAgICAgeTogZGF0YVksCiAgICAgICAgICAgICAgICAgICAgdGltZTogdGhpcy50aW1lSW5zcGVjdE1vZGUgJiYgdGhpcy5jdXJUaW1lID8gdGhpcy5jdXJUaW1lIDogJycsCiAgICAgICAgICAgICAgICAgICAgZ3JvdXBJRDogZ3JvdXBJRAogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9OwogICAgICAgICAgICB0aGlzLnRyZWVXb3JrZXIucG9zdE1lc3NhZ2UobWVzc2FnZSk7CiAgICAgICAgfSwKCiAgICAgICAgbW91c2Vtb3ZlSGFuZGxlcihlKSB7CiAgICAgICAgICAgIC8vIFNob3cgdG9vbHRpcCB3aGVuIG1vdXNlIG92ZXIgYSBkYXRhIHBvaW50IG9uIGNhbnZhcwogICAgICAgICAgICAvLyBXZSBuZWVkIHRvIHVzZSBjb2xvciBwaWNraW5nIHRvIGZpZ3VyZSBvdXQgd2hpY2ggcG9pbnQgaXMgaG92ZXJlZCBvdmVyCiAgICAgICAgICAgIGNvbnN0IHggPSBlLm9mZnNldFg7CiAgICAgICAgICAgIGNvbnN0IHkgPSBlLm9mZnNldFk7CiAgICAgICAgICAgIHRoaXMubGFzdE1vdXNlQ2xpZW50UG9zaXRpb24gPSB7IHg6IHgsIHk6IHkgfTsKCiAgICAgICAgICAgIC8vIFNob3cgcG9pbnQgaGlnaGxpZ2h0CiAgICAgICAgICAgIGlmIChhbnlUcnVlKHRoaXMuc2hvd1BvaW50cykgJiYgIXRoaXMuaGlkZUhpZ2hsaWdodHMpIHsKICAgICAgICAgICAgICAgIHRoaXMubW91c2VvdmVyUG9pbnQoeCwgeSk7CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIC8vIFNob3cgbGFiZWxzCiAgICAgICAgICAgIGlmICghdGhpcy5oaWRlSGlnaGxpZ2h0cykgewogICAgICAgICAgICAgICAgbW91c2VvdmVyTGFiZWwodGhpcywgeCwgeSk7CiAgICAgICAgICAgIH0KICAgICAgICB9LAoKICAgICAgICBnZXRDdXJab29tQm94KCkgewogICAgICAgICAgICBjb25zdCBib3ggPSB7CiAgICAgICAgICAgICAgICB4OiB0aGlzLmN1clpvb21UcmFuc2Zvcm0uaW52ZXJ0WCgwKSwKICAgICAgICAgICAgICAgIHk6IHRoaXMuY3VyWm9vbVRyYW5zZm9ybS5pbnZlcnRZKDApLAogICAgICAgICAgICAgICAgd2lkdGg6IE1hdGguYWJzKAogICAgICAgICAgICAgICAgICAgIHRoaXMuY3VyWm9vbVRyYW5zZm9ybS5pbnZlcnRYKHRoaXMuc3ZnRnVsbFNpemUud2lkdGgpIC0KICAgICAgICAgICAgICAgICAgICB0aGlzLmN1clpvb21UcmFuc2Zvcm0uaW52ZXJ0WCgwKQogICAgICAgICAgICAgICAgKSwKICAgICAgICAgICAgICAgIGhlaWdodDogTWF0aC5hYnMoCiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJab29tVHJhbnNmb3JtLmludmVydFkodGhpcy5zdmdGdWxsU2l6ZS5oZWlnaHQpIC0KICAgICAgICAgICAgICAgICAgICB0aGlzLmN1clpvb21UcmFuc2Zvcm0uaW52ZXJ0WSgwKQogICAgICAgICAgICAgICAgKQogICAgICAgICAgICB9OwogICAgICAgICAgICByZXR1cm4gYm94OwogICAgICAgIH0KICAgIH0sCiAgICBjb21wdXRlZDogewogICAgICAgIC4uLm1hcFN0YXRlKHsKICAgICAgICAgICAgaWNvblNob3c6ICJpY29uU2hvdyIsCiAgICAgICAgfSksCiAgICB9LAogICAgd2F0Y2g6IHsKICAgICAgICBpY29uU2hvdzogewogICAgICAgICAgICBoYW5kbGVyKG5ld1ZhbCkgewogICAgICAgICAgICAgICAgdGhpcy5zaG93R3JpZCA9IG5ld1ZhbC5ncmlkOwogICAgICAgICAgICAgICAgdGhpcy50b3BpY0NhbnZhc2VzLmZvckVhY2goYyA9PiB7CiAgICAgICAgICAgICAgICAgICAgYy5jbGFzc2VkKCdoaWRkZW4nLCAhdGhpcy5zaG93R3JpZCk7CiAgICAgICAgICAgICAgICB9KTsKCgogICAgICAgICAgICB9LAogICAgICAgICAgICBkZWVwOiB0cnVlLAogICAgICAgIH0KICAgIH0KfTsKCgo="},{"version":3,"sources":["DistributionView.vue"],"names":[],"mappings":";AAqBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;AAIA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA","file":"DistributionView.vue","sourceRoot":"src/views/MainView/MiddleMainView","sourcesContent":["<template>\n    <div class=\"mapview-class\">\n        <div id=\"popper-tooltip-top\" class=\"popper-tooltip hidden\" role=\"tooltip\">\n            <span class=\"popper-content\"></span>\n            <div class=\"popper-arrow\"></div>\n        </div>\n\n        <div id=\"popper-tooltip-bottom\" class=\"popper-tooltip hidden\" role=\"tooltip\">\n            <span class=\"popper-content\"></span>\n            <div class=\"popper-arrow\"></div>\n        </div>\n\n        <div v-if=\"this.$store.state.isDone['DisT']\" class=\"distribution-main\" ref=\"distributionMain\">\n        </div>\n\n    </div>\n\n</template>\n\n\n<script>\nimport { mapState } from \"vuex\";\nimport { config } from '@/config/config';\nimport createRegl from 'regl';\nimport d3 from '../../../utils/d3-import';\nimport { initWebGLMatrices, initWebGLBuffers, drawScatterPlot, drawGroupContour, updateWebGLBuffers, anyTrue, allTrue, highlightPoint, displayGroupChanged } from '../../../components/Embedding/Embedding';\nimport { redrawTopicGrid, mouseoverLabel } from '../../../components/Embedding/EmbeddingLabel';\nimport LoaderWorker from '../../../components/Embedding/workers/loader.worker.js';\nimport TreeWorker from '../../../components/Embedding/workers/tree.worker.js';\nimport * as PointDrawer from '../../../components/Embedding/EmbeddingPointWebGL'\nimport { HOVER_RADIUS } from '../../../utils/utils';\n\nexport default {\n    name: \"DistributionView\",\n    components: {\n\n    },\n    data() {\n        return {\n            component: null,    // HTMLElement： d3.select('.distribution-main')\n\n            svg: null,    // d3.Selection<HTMLElement, unknown, null, undefined>, unsed for drawing contour\n            svgFullSize: { width: 0, height: 0 },   // Size\n            svgSize: { width: 0, height: 0 }, // square draw \n            svgPadding: { top: 0, bottom: 0, left: 0, right: 0 }, // Padding\n\n            topSvg: null,   // d3.Selection<HTMLElement, unknown, null, undefined>, unsed for drawing hightlights\n            topicCanvases: [],  // used for drawing embedding points and others\n\n            // points\n            pointCanvas: null,\n            pointRegl: null,\n            frontPositionBuffer: null,\n            frontTextureCoordinateBuffer: null,\n            frontBufferPointSize: 0,\n\n            // search\n            searchPointCanvas: null,\n            searchPointRegl: null,\n            searchPointPositionBuffer: null,\n            searchPointTextureCoordinateBuffer: null,\n            searchPointResults: null,\n\n            // Tooltips\n            tooltipTop: null,\n            tooltipBottom: null,\n            hoverPoint: null,\n\n            xScale: null,\n            yScale: null,\n\n            // zooming\n            zoom: null, // d3.ZoomBehavior<HTMLElement, unknown>\n            initZoomTransform: null,\n            curZoomTransform: null,\n            curZoomLevel: 1,\n\n            // interaction\n            lastMouseClientPosition: null,\n            hideHighlights: false,\n\n            // user settings\n            showContours: [],\n            showGrid: true,\n            showPoints: [false],\n            showLabel: false,\n\n            // data\n            dataURLs: null,\n            promptPoints: [],\n            gridData: null,\n            tileData: null,\n            contours: null,\n            groupContour: null,\n            contoursInitialized: false,\n            loadedPointCount: 1,\n\n            // Time\n            timeTextureMap: null,\n\n            // Group\n            groupNames: [],\n\n            // search\n            completedSearchQueryID: null,\n\n            // scatter plot\n            webGLMatrices: null,\n            curPointWidth: 1,\n\n            // display labels\n            topicLevelTrees: new Map(),\n            lastGridTreeLevels: [],\n\n\n\n            // Web workers\n            loaderWorker: null,\n            treeWorker: null,\n\n            // store\n            footerStoreValue: { xScale: null, embeddingName: null, numPoints: null },\n\n\n            // other top\n            DEBUG: config.debug,\n\n            handledFooterMessageID: 0,\n\n\n        };\n    },\n    mounted() {\n\n        this.init();\n\n    },\n    methods: {\n        init() {\n\n            const dag = this.$refs.distributionMain;\n            this.svgFullSize.height = dag.clientHeight;\n            this.svgFullSize.width = dag.clientWidth;\n\n\n            this.component = d3.select('.distribution-main');\n            this.showGrid = true;\n\n\n            this.initWorker();\n\n            this.initTopSvg();\n            // Initialize the canvases\n            this.initCanvas();\n            // \n            this.initSVGGroups();\n\n            this.initData().then(() => {\n\n                initWebGLMatrices(this); // 确保 this 指向 Vue 实例\n\n                initWebGLBuffers(this);\n\n                drawScatterPlot(this);\n\n                displayGroupChanged(this, \"Image\")\n\n                // PointDrawer.drawGroupContour(this);\n\n                this.topicCanvases.forEach(c => c.classed('hidden', !this.showGrid));\n                this.showPoints = [true];\n                redrawTopicGrid(this, null);\n            });\n\n            // Register zoom\n            this.zoom = d3\n                .zoom()\n                .extent([\n                    [0, 0],\n                    [this.svgSize.width, this.svgSize.height]\n                ])\n                .scaleExtent([config.layout.zoomScale[0], config.layout.zoomScale[1]])\n                .interpolate(d3.interpolate)\n                .on('zoom', (g) => {\n                    (async () => {\n                        await this.zoomed(g);\n                    })();\n                })\n                .on('end', () => this.zoomEnded());\n\n            this.topSvg.call(this.zoom).on('dblclick.zoom', null);\n\n            this.tooltipTop = document.querySelector('#popper-tooltip-top');\n            this.tooltipBottom = document.querySelector('#popper-tooltip-bottom');\n\n            const squareCanvasWidth = Math.min(\n                this.svgFullSize.width - this.svgPadding.left - this.svgPadding.right,\n                this.svgFullSize.height - this.svgPadding.top - this.svgPadding.bottom\n            );\n\n            this.svgSize = {\n                width: squareCanvasWidth,\n                height: squareCanvasWidth\n            };\n\n\n            this.curZoomTransform = d3.zoomIdentity;\n\n        },\n        async initData() {\n\n            const gridData = await d3.json(this.$store.state.dataURLs.grid);\n            if (gridData === undefined) {\n                console.log('Fail to load grid data');\n            }\n\n            this.gridData = gridData;\n\n            // Initialize the data scales\n            const xRange = this.gridData.xRange;\n            const yRange = this.gridData.yRange;\n\n            let xLength = xRange[1] - xRange[0];\n            let yLength = yRange[1] - yRange[0];\n\n            if (!this.gridData.padded) {\n                // Add padding for the data\n                if (xLength < yLength) {\n                    yRange[0] -= yLength / 50;\n                    yRange[1] += yLength / 50;\n                    yLength = yRange[1] - yRange[0];\n\n                    xRange[0] -= (yLength - xLength) / 2;\n                    xRange[1] += (yLength - xLength) / 2;\n                } else {\n                    // Add padding for the data\n                    xRange[0] -= xLength / 50;\n                    xRange[1] += xLength / 50;\n                    xLength = xRange[1] - xRange[0];\n\n                    yRange[0] -= (xLength - yLength) / 2;\n                    yRange[1] += (xLength - yLength) / 2;\n                }\n            }\n            this.xScale = d3\n                .scaleLinear()\n                .domain(xRange)\n                .range([0, this.svgSize.width]);\n\n            this.yScale = d3\n                .scaleLinear()\n                .domain(yRange)\n                .range([this.svgSize.height, 0]);\n\n            // PointDrawer.drawGroupContour(this);\n\n\n            // Create group related structures if the data has groups\n            if (this.gridData.groupGrids && this.gridData.groupNames) {\n                this.groupNames = this.gridData.groupNames;\n                const umapGroup = this.svg.select('g.umap-group');\n\n                // Adjust the first contour's name\n                this.showContours = [];\n                this.showPoints = [];\n                this.groupContours = [];\n\n                for (let i = 0; i < this.groupNames.length; i++) {\n                    // Add groups to the control states\n                    // (Default is to show the first group only)\n                    this.showContours.push(i === 0);\n                    this.showPoints.push(i === 0);\n\n                    // Add contour elements for other groups\n                    const name = this.groupNames[i];\n                    umapGroup\n                        .append('g')\n                        .attr('class', `contour-group-generic contour-group-${name}`)\n                        .classed('hidden', i !== 0);\n\n                    // Drw the group contour\n                    const curContour = drawGroupContour(this, name);\n                    if (curContour !== null) {\n                        this.groupContours.push(curContour);\n                    }\n                }\n            }\n\n            // Tell the tree worker to prepare to add points to the tree\n            const groupIDs = [];\n\n            if (this.groupNames) {\n                for (let i = 0; i < this.groupNames.length; i++) {\n                    groupIDs.push(i);\n                }\n            }\n\n            const treeMessage = {\n                command: 'initQuadtree',\n                payload: {\n                    xRange: xRange,\n                    yRange: yRange,\n                    groupIDs: groupIDs,\n                    times: ['']\n                }\n            };\n\n            console.log(\"treeMessage\", groupIDs)\n            this.treeWorker.postMessage(treeMessage);\n\n            for (const level of Object.keys(this.gridData.topic.data)) {\n                const tree = d3\n                    .quadtree()\n                    .x(function (d) { return d[0]; })\n                    .y(function (d) { return d[1]; })\n                    .addAll(this.gridData.topic.data[level]);\n                this.topicLevelTrees.set(parseInt(level, 10), tree);\n            }\n\n\n\n\n        },\n        initCanvas() {\n\n            const discomponent = this.$refs.distributionMain;\n            this.pointCanvas = d3.select(discomponent)\n                .append('canvas')\n                .attr('class', 'embedding-canvas')\n                .attr('width', this.svgFullSize.width)\n                .attr('height', this.svgFullSize.height);\n\n            this.pointRegl = createRegl(this.pointCanvas?.node());\n\n            // this.searchPointCanvas = d3.select(discomponent)\n            //     .append('canvas')\n            //     .attr('class', 'search-point-canvas')\n            //     .attr('width', this.svgFullSize.width)\n            //     .attr('height', this.svgFullSize.height);\n\n            // this.searchPointRegl = createRegl(this.searchPointCanvas?.node());\n\n            this.topicCanvases = [];\n            for (const pos of ['top', 'bottom']) {\n                this.topicCanvases.push(\n                    d3\n                        .select(discomponent)\n                        .append('canvas')\n                        .attr('class', `topic-grid-canvas ${pos}`)\n                        .attr('width', `${this.svgFullSize.width}px`)\n                        .attr('height', `${this.svgFullSize.height}px`)\n                        .classed('hidden', !this.showGrid)\n                );\n            }\n\n        },\n        initSVGGroups() {\n\n            this.svg = this.component.append('svg')\n                .attr('class', \"embedding-svg\")\n                .attr('width', this.svgFullSize.width)\n                .attr('height', this.svgFullSize.height);\n\n\n            const umapGroup = this.svg\n                .append('g')\n                .attr('class', 'umap-group')\n                .attr(\n                    'transform',\n                    `translate(${this.svgPadding.left}, ${this.svgPadding.top})`\n                );\n\n            umapGroup\n                .append('g')\n                .attr('class', 'contour-group')\n                .classed('hidden', !this.showContours);\n\n        },\n        initTopSvg() {\n\n            // 创建一个 SVG 元素并设置其属性\n            this.topSvg = this.component.append('svg')\n                .attr('class', \"top-svg\")\n                .attr('width', `${this.svgFullSize.width}px`)\n                .attr('height', `${this.svgFullSize.height}px`) // 设置高度\n                .on('pointermove', e => this.mousemoveHandler(e))\n                .on('mouseleave', () => {\n                    highlightPoint(this, { point: undefined, animated: false });\n                    mouseoverLabel(this, null, null);\n                })\n                .attr(\n                    'transform',\n                    `translate(${this.svgPadding.left}, ${this.svgPadding.top})`\n                );\n\n\n            const topGroup = this.topSvg.append('g').attr('class', 'top-group');\n\n            topGroup\n                .append('rect')\n                .attr('class', 'mouse-track-rect')\n                .attr('width', this.svgFullSize.width)\n                .attr('height', this.svgFullSize.height);\n\n            const topContent = topGroup.append('g').attr('class', 'top-content');\n\n            topContent.append('g').attr('class', 'topics-bottom');\n            topContent\n                .append('g')\n                .attr('class', 'topics')\n                .classed('hidden', !this.showLabel);\n            topContent.append('g').attr('class', 'topics-top');\n            topContent.append('g').attr('class', 'highlights');\n\n\n\n        },\n        zoomed(e) {\n\n            const transform = e.transform;\n            const scaleChanged = this.curZoomTransform.k !== transform.k;\n            this.curZoomTransform = transform;\n\n            // === Task (1) ===\n            // Transform the SVG elements\n            this.svg.select('.umap-group').attr('transform', transform.toString());\n\n            // Transform the top SVG elements\n            this.topSvg\n                .select('.top-group')\n                .attr('transform', transform.toString());\n\n            // Transform the visible canvas elements\n            if (anyTrue(this.showPoints)) {\n                if (this.frontPositionBuffer && this.frontTextureCoordinateBuffer) {\n                    drawScatterPlot(this);\n                }\n            }\n\n            if (this.showGrid) {\n                redrawTopicGrid(this, null);\n            }\n\n\n\n        },\n        // Event handler for zoom ended\n        zoomEnded() {\n            console.log(\"svg zoom end !!!\")\n        },\n        initWorker() {\n            // Initialize the web worker to load data and deal with the quadtree\n            this.loaderWorker = new LoaderWorker();\n            console.log(\"LoaderWorker\", LoaderWorker)\n            this.loaderWorker.onmessage = (e) => {\n                this.loaderWorkerMessageHandler(e);\n            };\n\n            this.treeWorker = new TreeWorker();\n            console.log(\"treeWorker\", this.treeWorker)\n            this.treeWorker.onmessage = (e) => {\n                this.treeWorkerMessageHandler(e);\n            };\n        },\n        loaderWorkerMessageHandler(e) {\n            switch (e.data.command) {\n                case 'transferLoadData': {\n                    // Add these points to the quadtree ASAP\n                    const treeMessage = {\n                        command: 'updateQuadtree',\n                        payload: {\n                            points: e.data.payload.points\n                        }\n                    };\n                    this.treeWorker.postMessage(treeMessage);\n\n                    if (e.data.payload.isFirstBatch) {\n                        // Add the first batch points\n                        this.promptPoints = e.data.payload.points;\n\n                        initWebGLBuffers(this);\n                        if (anyTrue(this.showPoints)) {\n                            drawScatterPlot(this);\n                        }\n\n                        // Add the points to the search index\n                        const searchMessage = {\n                            command: 'addPoints',\n                            payload: {\n                                points: e.data.payload.points\n                            }\n                        };\n                        // this.searchWorker.postMessage(searchMessage);\n                    } else {\n                        // Batches after the first batch\n                        // Add the points to the prompt point list\n                        const newPoints = e.data.payload.points;\n                        for (const point of newPoints) {\n                            this.promptPoints.push(point);\n                        }\n\n                        // Add the points to the search index\n                        // const searchMessage = {\n                        //     command: 'addPoints',\n                        //     payload: {\n                        //         points: newPoints\n                        //     }\n                        // };\n                        // this.searchWorker.postMessage(searchMessage);\n\n                        // Add the new points to the WebGL buffers\n                        updateWebGLBuffers(this, newPoints);\n                        if (anyTrue(this.showPoints)) {\n                            drawScatterPlot(this);\n                        }\n\n                        if (e.data.payload.isLastBatch) {\n                            console.log('Finished loading all data.');\n                        }\n                    }\n\n                    // Update the data point count\n                    this.loadedPointCount = e.data.payload.loadedPointCount;\n\n                    // Update the footer\n                    this.footerStoreValue.numPoints = this.promptPoints.length;\n                    // this.footerStore.set(this.footerStoreValue);\n                    break;\n                }\n\n                default: {\n                    console.error('Unknown message', e.data.command);\n                    break;\n                }\n            }\n        },\n        treeWorkerMessageHandler(e) {\n            switch (e.data.command) {\n                case 'finishInitQuadtree': {\n                    // Tell the loader worker to start loading data\n                    // (need to wait to set up the quadtree to avoid racing)\n                    const message = {\n                        command: 'startLoadData',\n                        payload: { url: this.$store.state.dataURLs.point }\n                    };\n                    this.loaderWorker.postMessage(message);\n                    break;\n                }\n\n                case 'finishQuadtreeSearch': {\n                    if (this.lastMouseClientPosition === null) {\n                        throw new Error('lastMouseClientPosition is null');\n                    }\n                    // Check if the closest point is relatively close to the mouse\n                    const closestPoint = structuredClone(\n                        e.data.payload.point\n                    );\n                    const screenPointX = this.curZoomTransform.applyX(\n                        this.xScale(closestPoint.x)\n                    );\n                    const screenPointY = this.curZoomTransform.applyY(\n                        this.yScale(closestPoint.y)\n                    );\n\n                    const distance = Math.max(\n                        Math.abs(screenPointX - this.lastMouseClientPosition.x),\n                        Math.abs(screenPointY - this.lastMouseClientPosition.y)\n                    );\n\n                    const highlightRadius = Math.max(\n                        10 / this.curZoomTransform.k,\n                        (config.layout.scatterDotRadius *\n                            Math.exp(Math.log(this.curZoomTransform.k) * 0.55)) /\n                        this.curZoomTransform.k\n                    );\n\n                    // Highlight the point if it is close enough to the mouse\n                    const curHoverRadius = Math.max(\n                        HOVER_RADIUS,\n                        highlightRadius * this.curZoomTransform.k\n                    );\n\n                    if (distance <= curHoverRadius) {\n                        highlightPoint(this, { point: closestPoint, animated: false });\n                    } else {\n                        highlightPoint(this, { point: undefined, animated: false });\n                    }\n                    break;\n                }\n\n                default: {\n                    console.error('Unknown message', e.data.command);\n                    break;\n                }\n            }\n        },\n\n        mouseoverPoint(x, y) {\n            // Invert to the stage scale => invert to the data scale\n            const dataX = this.xScale.invert(this.curZoomTransform.invertX(x));\n            const dataY = this.yScale.invert(this.curZoomTransform.invertY(y));\n\n            // Let the worker to search the closest point in a radius\n            let groupID = -1;\n\n            if (this.groupNames) {\n                if (allTrue(this.showPoints)) {\n                    groupID = -1;\n                } else {\n                    // TODO: Need a better way to search slices of groups for multi groups\n                    for (let i = 0; i < this.showPoints.length; i++) {\n                        if (this.showPoints[i]) {\n                            groupID = i;\n                            break;\n                        }\n                    }\n                }\n            }\n\n            const message = {\n                command: 'startQuadtreeSearch',\n                payload: {\n                    x: dataX,\n                    y: dataY,\n                    time: this.timeInspectMode && this.curTime ? this.curTime : '',\n                    groupID: groupID\n                }\n            };\n            this.treeWorker.postMessage(message);\n        },\n\n        mousemoveHandler(e) {\n            // Show tooltip when mouse over a data point on canvas\n            // We need to use color picking to figure out which point is hovered over\n            const x = e.offsetX;\n            const y = e.offsetY;\n            this.lastMouseClientPosition = { x: x, y: y };\n\n            // Show point highlight\n            if (anyTrue(this.showPoints) && !this.hideHighlights) {\n                this.mouseoverPoint(x, y);\n            }\n\n            // Show labels\n            if (!this.hideHighlights) {\n                mouseoverLabel(this, x, y);\n            }\n        },\n\n        getCurZoomBox() {\n            const box = {\n                x: this.curZoomTransform.invertX(0),\n                y: this.curZoomTransform.invertY(0),\n                width: Math.abs(\n                    this.curZoomTransform.invertX(this.svgFullSize.width) -\n                    this.curZoomTransform.invertX(0)\n                ),\n                height: Math.abs(\n                    this.curZoomTransform.invertY(this.svgFullSize.height) -\n                    this.curZoomTransform.invertY(0)\n                )\n            };\n            return box;\n        }\n    },\n    computed: {\n        ...mapState({\n            iconShow: \"iconShow\",\n        }),\n    },\n    watch: {\n        iconShow: {\n            handler(newVal) {\n                this.showGrid = newVal.grid;\n                this.topicCanvases.forEach(c => {\n                    c.classed('hidden', !this.showGrid);\n                });\n\n\n            },\n            deep: true,\n        }\n    }\n};\n\n\n</script>\n\n<style lang=\"scss\">\n@use './DistributionView.scss';\n</style>"]}]}