{"remainingRequest":"/home/yansha/VDProject/VDFrontend/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/yansha/VDProject/VDFrontend/src/views/MainView/MiddleMainView/DistributionView.vue?vue&type=script&lang=js","dependencies":[{"path":"/home/yansha/VDProject/VDFrontend/src/views/MainView/MiddleMainView/DistributionView.vue","mtime":1735205397723},{"path":"/home/yansha/VDProject/VDFrontend/node_modules/cache-loader/dist/cjs.js","mtime":1735202380381},{"path":"/home/yansha/VDProject/VDFrontend/node_modules/babel-loader/lib/index.js","mtime":1735202380921},{"path":"/home/yansha/VDProject/VDFrontend/node_modules/cache-loader/dist/cjs.js","mtime":1735202380381},{"path":"/home/yansha/VDProject/VDFrontend/node_modules/vue-loader/lib/index.js","mtime":1735202381045}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CmltcG9ydCBhcGkgZnJvbSAiQC9hcGkvZGF0YSI7CmltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJzsKaW1wb3J0IHsgRm9udExvYWRlciB9IGZyb20gJ3RocmVlL2V4YW1wbGVzL2pzbS9sb2FkZXJzL0ZvbnRMb2FkZXInOwppbXBvcnQgeyBPcmJpdENvbnRyb2xzIH0gZnJvbSAndGhyZWUvZXhhbXBsZXMvanNtL2NvbnRyb2xzL09yYml0Q29udHJvbHMnOwppbXBvcnQgeyBtYXBTdGF0ZSB9IGZyb20gInZ1ZXgiOwppbXBvcnQgeyBjb25maWcgfSBmcm9tICdAL2NvbmZpZy9jb25maWcnOwppbXBvcnQgY3JlYXRlUmVnbCBmcm9tICdyZWdsJzsKaW1wb3J0IGQzIGZyb20gJy4uLy4uLy4uL3V0aWxzL2QzLWltcG9ydCc7CmltcG9ydCB7IGluaXRXZWJHTE1hdHJpY2VzLCBpbml0V2ViR0xCdWZmZXJzLCBkcmF3U2NhdHRlclBsb3QsIGRyYXdHcm91cENvbnRvdXIgfSBmcm9tICcuLi9NaWRkbGVNYWluVmlldy9FbWJlZGRpbmcnOwovLyBpbXBvcnQgeyBMb2FkZXJXb3JrZXJNZXNzYWdlIH0gZnJvbSAnLi4vLi4vLi4vLi4vdHlwZXMvZW1iZWRkaW5nLXR5cGVzJzsKaW1wb3J0IExvYWRlcldvcmtlciBmcm9tICcuLi8uLi8uLi9jb21wb25lbnRzL0VtYmVkZGluZy93b3JrZXJzL2xvYWRlci53b3JrZXI/d29ya2VyJmlubGluZSc7CmltcG9ydCBUcmVlV29ya2VyIGZyb20gJy4uLy4uLy4uL2NvbXBvbmVudHMvRW1iZWRkaW5nL3dvcmtlcnMvdHJlZS53b3JrZXI/d29ya2VyJmlubGluZSc7CgpleHBvcnQgZGVmYXVsdCB7CiAgICBuYW1lOiAiRGlzdHJpYnV0aW9uVmlldyIsCiAgICBjb21wb25lbnRzOiB7CgogICAgfSwKICAgIGRhdGEoKSB7CiAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgY29tcG9uZW50OiBudWxsLCAgICAvLyBIVE1MRWxlbWVudO+8miBkMy5zZWxlY3QoJy5kaXN0cmlidXRpb24tbWFpbicpCgogICAgICAgICAgICBzdmc6IG51bGwsICAgIC8vIGQzLlNlbGVjdGlvbjxIVE1MRWxlbWVudCwgdW5rbm93biwgbnVsbCwgdW5kZWZpbmVkPiwgdW5zZWQgZm9yIGRyYXdpbmcgY29udG91cgogICAgICAgICAgICBzdmdGdWxsU2l6ZTogeyB3aWR0aDogMCwgaGVpZ2h0OiAwIH0sICAgLy8gU2l6ZQogICAgICAgICAgICBzdmdTaXplOiB7IHdpZHRoOiAwLCBoZWlnaHQ6IDAgfSwgLy8gc3F1YXJlIGRyYXcgCiAgICAgICAgICAgIHN2Z1BhZGRpbmc6IHsgdG9wOiAwLCBib3R0b206IDAsIGxlZnQ6IDAsIHJpZ2h0OiAwIH0sIC8vIFBhZGRpbmcKCiAgICAgICAgICAgIHRvcFN2ZzogbnVsbCwgICAvLyBkMy5TZWxlY3Rpb248SFRNTEVsZW1lbnQsIHVua25vd24sIG51bGwsIHVuZGVmaW5lZD4sIHVuc2VkIGZvciBkcmF3aW5nIGhpZ2h0bGlnaHRzCiAgICAgICAgICAgIHRvcGljQ2FudmFzZXM6IFtdLCAgLy8gdXNlZCBmb3IgZHJhd2luZyBlbWJlZGRpbmcgcG9pbnRzIGFuZCBvdGhlcnMKCiAgICAgICAgICAgIC8vIHBvaW50cwogICAgICAgICAgICBwb2ludENhbnZhczogbnVsbCwKICAgICAgICAgICAgcG9pbnRSZWdsOiBudWxsLAogICAgICAgICAgICBmcm9udFBvc2l0aW9uQnVmZmVyOiBudWxsLAogICAgICAgICAgICBmcm9udFRleHR1cmVDb29yZGluYXRlQnVmZmVyOiBudWxsLAogICAgICAgICAgICBmcm9udEJ1ZmZlclBvaW50U2l6ZTogMCwKCiAgICAgICAgICAgIC8vIHNlYXJjaAogICAgICAgICAgICBzZWFyY2hQb2ludENhbnZhczogbnVsbCwKICAgICAgICAgICAgc2VhcmNoUG9pbnRSZWdsOiBudWxsLAoKICAgICAgICAgICAgLy8gc2V0dGluZwogICAgICAgICAgICB4U2NhbGU6IG51bGwsCiAgICAgICAgICAgIHlTY2FsZTogbnVsbCwKCiAgICAgICAgICAgIC8vIHNjYXR0ZXIgcGxvdAogICAgICAgICAgICB3ZWJHTE1hdHJpY2VzOiBudWxsLAogICAgICAgICAgICBjdXJQb2ludFdpZHRoOiAwLAoKICAgICAgICAgICAgY3VyWm9vbVRyYW5zZm9ybTogbnVsbCwKCiAgICAgICAgICAgIC8vIGRhdGEKICAgICAgICAgICAgZ3JpZERhdGE6IG51bGwsCiAgICAgICAgICAgIHBvaW50czogbnVsbCwKICAgICAgICAgICAgbG9hZGVkUG9pbnRDb3VudDogMSwKICAgICAgICAgICAgcmVkdWN0aW9uRGF0YTogW10sCgoKICAgICAgICAgICAgLy8gdXNlciBzZXR0aW5ncwogICAgICAgICAgICBzaG93Q29udG91cnM6IHRydWUsCiAgICAgICAgICAgIHNob3dQb2ludHM6IHRydWUsCgoKICAgICAgICAgICAgLy8gem9vbWluZwogICAgICAgICAgICB6b29tOiBudWxsLCAvLyBkMy5ab29tQmVoYXZpb3I8SFRNTEVsZW1lbnQsIHVua25vd24+CgogICAgICAgICAgICAvLyBXZWIgd29ya2VycwogICAgICAgICAgICBsb2FkZXJXb3JrZXI6IG51bGwsCiAgICAgICAgICAgIHRyZWVXb3JrZXI6IG51bGwsCgoKICAgICAgICB9OwogICAgfSwKICAgIG1vdW50ZWQoKSB7CgogICAgICAgIHRoaXMuaW5pdCgpOwoKICAgIH0sCiAgICBtZXRob2RzOiB7CiAgICAgICAgaW5pdCgpIHsKICAgICAgICAgICAgY29uc3QgZGFnID0gdGhpcy4kcmVmcy5kaXN0cmlidXRpb25NYWluOwogICAgICAgICAgICB0aGlzLnN2Z0Z1bGxTaXplLmhlaWdodCA9IGRhZy5jbGllbnRIZWlnaHQ7CiAgICAgICAgICAgIHRoaXMuc3ZnRnVsbFNpemUud2lkdGggPSBkYWcuY2xpZW50V2lkdGg7CgogICAgICAgICAgICB0aGlzLmNvbXBvbmVudCA9IGQzLnNlbGVjdCgnLmRpc3RyaWJ1dGlvbi1tYWluJyk7CgogICAgICAgICAgICAvLwogICAgICAgICAgICB0aGlzLmluaXRUb3BTdmcoKTsKCiAgICAgICAgICAgIC8vIEluaXRpYWxpemUgdGhlIGNhbnZhc2VzCiAgICAgICAgICAgIHRoaXMuaW5pdENhbnZhcygpOwoKICAgICAgICAgICAgLy8gCiAgICAgICAgICAgIHRoaXMuaW5pdFNWR0dyb3VwcygpOwoKICAgICAgICAgICAgLy8gUmVnaXN0ZXIgem9vbQogICAgICAgICAgICB0aGlzLnpvb20gPSBkMwogICAgICAgICAgICAgICAgLnpvb20oKQogICAgICAgICAgICAgICAgLmV4dGVudChbCiAgICAgICAgICAgICAgICAgICAgWzAsIDBdLAogICAgICAgICAgICAgICAgICAgIFt0aGlzLnN2Z1NpemUud2lkdGgsIHRoaXMuc3ZnU2l6ZS5oZWlnaHRdCiAgICAgICAgICAgICAgICBdKQogICAgICAgICAgICAgICAgLnNjYWxlRXh0ZW50KFtjb25maWcubGF5b3V0Lnpvb21TY2FsZVswXSwgY29uZmlnLmxheW91dC56b29tU2NhbGVbMV1dKQogICAgICAgICAgICAgICAgLmludGVycG9sYXRlKGQzLmludGVycG9sYXRlKQogICAgICAgICAgICAgICAgLm9uKCd6b29tJywgKGcpID0+IHsKICAgICAgICAgICAgICAgICAgICAoYXN5bmMgKCkgPT4gewogICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnpvb21lZChnKTsKICAgICAgICAgICAgICAgICAgICB9KSgpOwogICAgICAgICAgICAgICAgfSkKICAgICAgICAgICAgICAgIC5vbignZW5kJywgKCkgPT4gdGhpcy56b29tRW5kZWQoKSk7CgogICAgICAgICAgICB0aGlzLnRvcFN2Zy5jYWxsKHRoaXMuem9vbSkub24oJ2RibGNsaWNrLnpvb20nLCBudWxsKTsKCgogICAgICAgICAgICB0aGlzLnBvaW50cyA9IHRoaXMuJHN0b3JlLnN0YXRlLnJlZHVjdGlvbkluZm87CiAgICAgICAgICAgIHRoaXMuZ3JpZERhdGEgPSB0aGlzLiRzdG9yZS5zdGF0ZS5ncmlkRGVuc2l0eTsKCiAgICAgICAgICAgIGNvbnN0IHNxdWFyZUNhbnZhc1dpZHRoID0gTWF0aC5taW4oCiAgICAgICAgICAgICAgICB0aGlzLnN2Z0Z1bGxTaXplLndpZHRoIC0gdGhpcy5zdmdQYWRkaW5nLmxlZnQgLSB0aGlzLnN2Z1BhZGRpbmcucmlnaHQsCiAgICAgICAgICAgICAgICB0aGlzLnN2Z0Z1bGxTaXplLmhlaWdodCAtIHRoaXMuc3ZnUGFkZGluZy50b3AgLSB0aGlzLnN2Z1BhZGRpbmcuYm90dG9tCiAgICAgICAgICAgICk7CgogICAgICAgICAgICB0aGlzLnN2Z1NpemUgPSB7CiAgICAgICAgICAgICAgICB3aWR0aDogc3F1YXJlQ2FudmFzV2lkdGgsCiAgICAgICAgICAgICAgICBoZWlnaHQ6IHNxdWFyZUNhbnZhc1dpZHRoCiAgICAgICAgICAgIH07CgogICAgICAgICAgICAvLyBJbml0aWFsaXplIHRoZSBkYXRhIHNjYWxlcwogICAgICAgICAgICBjb25zdCB4UmFuZ2UgPSB0aGlzLmdyaWREYXRhLnhSYW5nZTsKICAgICAgICAgICAgY29uc3QgeVJhbmdlID0gdGhpcy5ncmlkRGF0YS55UmFuZ2U7CgogICAgICAgICAgICAvLyBGb3JjZSB0aGUgcGxvdCB0byBiZSBhIHNxdWFyZQogICAgICAgICAgICBsZXQgeExlbmd0aCA9IHhSYW5nZVsxXSAtIHhSYW5nZVswXTsKICAgICAgICAgICAgbGV0IHlMZW5ndGggPSB5UmFuZ2VbMV0gLSB5UmFuZ2VbMF07CgogICAgICAgICAgICBpZiAoIXRoaXMuZ3JpZERhdGEucGFkZGVkKSB7CiAgICAgICAgICAgICAgICAvLyBBZGQgcGFkZGluZyBmb3IgdGhlIGRhdGEKICAgICAgICAgICAgICAgIGlmICh4TGVuZ3RoIDwgeUxlbmd0aCkgewogICAgICAgICAgICAgICAgICAgIHlSYW5nZVswXSAtPSB5TGVuZ3RoIC8gNTA7CiAgICAgICAgICAgICAgICAgICAgeVJhbmdlWzFdICs9IHlMZW5ndGggLyA1MDsKICAgICAgICAgICAgICAgICAgICB5TGVuZ3RoID0geVJhbmdlWzFdIC0geVJhbmdlWzBdOwoKICAgICAgICAgICAgICAgICAgICB4UmFuZ2VbMF0gLT0gKHlMZW5ndGggLSB4TGVuZ3RoKSAvIDI7CiAgICAgICAgICAgICAgICAgICAgeFJhbmdlWzFdICs9ICh5TGVuZ3RoIC0geExlbmd0aCkgLyAyOwogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAvLyBBZGQgcGFkZGluZyBmb3IgdGhlIGRhdGEKICAgICAgICAgICAgICAgICAgICB4UmFuZ2VbMF0gLT0geExlbmd0aCAvIDUwOwogICAgICAgICAgICAgICAgICAgIHhSYW5nZVsxXSArPSB4TGVuZ3RoIC8gNTA7CiAgICAgICAgICAgICAgICAgICAgeExlbmd0aCA9IHhSYW5nZVsxXSAtIHhSYW5nZVswXTsKCiAgICAgICAgICAgICAgICAgICAgeVJhbmdlWzBdIC09ICh4TGVuZ3RoIC0geUxlbmd0aCkgLyAyOwogICAgICAgICAgICAgICAgICAgIHlSYW5nZVsxXSArPSAoeExlbmd0aCAtIHlMZW5ndGgpIC8gMjsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICB0aGlzLnhTY2FsZSA9IGQzCiAgICAgICAgICAgICAgICAuc2NhbGVMaW5lYXIoKQogICAgICAgICAgICAgICAgLmRvbWFpbih4UmFuZ2UpCiAgICAgICAgICAgICAgICAucmFuZ2UoWzAsIHRoaXMuc3ZnU2l6ZS53aWR0aF0pOwoKICAgICAgICAgICAgdGhpcy55U2NhbGUgPSBkMwogICAgICAgICAgICAgICAgLnNjYWxlTGluZWFyKCkKICAgICAgICAgICAgICAgIC5kb21haW4oeVJhbmdlKQogICAgICAgICAgICAgICAgLnJhbmdlKFt0aGlzLnN2Z1NpemUuaGVpZ2h0LCAwXSk7CgogICAgICAgICAgICB0aGlzLmN1clpvb21UcmFuc2Zvcm0gPSBkMy56b29tSWRlbnRpdHk7CgogICAgICAgICAgICBpbml0V2ViR0xNYXRyaWNlcyh0aGlzKTsgLy8g56Gu5L+dIHRoaXMg5oyH5ZCRIFZ1ZSDlrp7kvosKICAgICAgICAgICAgaW5pdFdlYkdMQnVmZmVycyh0aGlzKTsKICAgICAgICAgICAgZHJhd1NjYXR0ZXJQbG90KHRoaXMpOwoKICAgICAgICAgICAgZHJhd0dyb3VwQ29udG91cih0aGlzKTsKCiAgICAgICAgICAgIHRoaXMuaW5pdFdvcmtlcigpOwoKICAgICAgICAgICAgY29uc3QgdHJlZU1lc3NhZ2UgPSB7CiAgICAgICAgICAgIGNvbW1hbmQ6ICdpbml0UXVhZHRyZWUnLAogICAgICAgICAgICBwYXlsb2FkOiB7CiAgICAgICAgICAgICAgICB4UmFuZ2U6IHhSYW5nZSwKICAgICAgICAgICAgICAgIHlSYW5nZTogeVJhbmdlLAogICAgICAgICAgICAgICAgZ3JvdXBJRHM6IG51bGwsCiAgICAgICAgICAgICAgICB0aW1lczogW10KICAgICAgICAgICAgfQogICAgICAgICAgICB9OwogICAgICAgICAgICBjb25zb2xlLmxvZygiYW5kIHBvc3QgbWVzc2FnZSB0byB3b3JrZXIhISEiLCB0cmVlTWVzc2FnZSkKCgoKICAgICAgICAgICAgdGhpcy50cmVlV29ya2VyLnBvc3RNZXNzYWdlKHRyZWVNZXNzYWdlKTsKCgoKCiAgICAgICAgfSwKICAgICAgICBpbml0Q2FudmFzKCkgewoKICAgICAgICAgICAgY29uc3QgZGlzY29tcG9uZW50ID0gdGhpcy4kcmVmcy5kaXN0cmlidXRpb25NYWluOwogICAgICAgICAgICB0aGlzLnBvaW50Q2FudmFzID0gZDMuc2VsZWN0KGRpc2NvbXBvbmVudCkKICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2NhbnZhcycpCiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW1iZWRkaW5nLWNhbnZhcycpCiAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCB0aGlzLnN2Z0Z1bGxTaXplLndpZHRoKQogICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIHRoaXMuc3ZnRnVsbFNpemUuaGVpZ2h0KTsKCiAgICAgICAgICAgIHRoaXMucG9pbnRSZWdsID0gY3JlYXRlUmVnbCh0aGlzLnBvaW50Q2FudmFzPy5ub2RlKCkpOwoKICAgICAgICAgICAgLy8gdGhpcy5zZWFyY2hQb2ludENhbnZhcyA9IGQzLnNlbGVjdChkaXNjb21wb25lbnQpCiAgICAgICAgICAgIC8vICAgICAuYXBwZW5kKCdjYW52YXMnKQogICAgICAgICAgICAvLyAgICAgLmF0dHIoJ2NsYXNzJywgJ3NlYXJjaC1wb2ludC1jYW52YXMnKQogICAgICAgICAgICAvLyAgICAgLmF0dHIoJ3dpZHRoJywgdGhpcy5zdmdGdWxsU2l6ZS53aWR0aCkKICAgICAgICAgICAgLy8gICAgIC5hdHRyKCdoZWlnaHQnLCB0aGlzLnN2Z0Z1bGxTaXplLmhlaWdodCk7CgogICAgICAgICAgICAvLyB0aGlzLnNlYXJjaFBvaW50UmVnbCA9IGNyZWF0ZVJlZ2wodGhpcy5zZWFyY2hQb2ludENhbnZhcz8ubm9kZSgpKTsKCiAgICAgICAgICAgIC8vIHRoaXMudG9waWNDYW52YXNlcyA9IFtdOwogICAgICAgICAgICAvLyBmb3IgKGNvbnN0IHBvcyBvZiBbJ3RvcCcsICdib3R0b20nXSkgewogICAgICAgICAgICAvLyAgICAgdGhpcy50b3BpY0NhbnZhc2VzLnB1c2goCiAgICAgICAgICAgIC8vICAgICAgICAgZDMKICAgICAgICAgICAgLy8gICAgICAgICAgICAgLnNlbGVjdChkaXNjb21wb25lbnQpCiAgICAgICAgICAgIC8vICAgICAgICAgICAgIC5hcHBlbmQoJ2NhbnZhcycpCiAgICAgICAgICAgIC8vICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIGB0b3BpYy1ncmlkLWNhbnZhcy4ke3Bvc31gKQogICAgICAgICAgICAvLyAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCBgJHt0aGlzLnN2Z0Z1bGxTaXplLndpZHRofXB4YCkKICAgICAgICAgICAgLy8gICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGAke3RoaXMuc3ZnRnVsbFNpemUuaGVpZ2h0fXB4YCkKICAgICAgICAgICAgLy8gICAgICk7CiAgICAgICAgICAgIC8vIH0KCiAgICAgICAgfSwKICAgICAgICBpbml0U1ZHR3JvdXBzKCkgewoKICAgICAgICAgICAgdGhpcy5zdmcgPSB0aGlzLmNvbXBvbmVudC5hcHBlbmQoJ3N2ZycpCiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAiZW1iZWRkaW5nLXN2ZyIpCiAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCB0aGlzLnN2Z0Z1bGxTaXplLndpZHRoKQogICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIHRoaXMuc3ZnRnVsbFNpemUuaGVpZ2h0KTsKCgogICAgICAgICAgICBjb25zdCB1bWFwR3JvdXAgPSB0aGlzLnN2ZwogICAgICAgICAgICAgICAgLmFwcGVuZCgnZycpCiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAndW1hcC1ncm91cCcpCiAgICAgICAgICAgICAgICAuYXR0cigKICAgICAgICAgICAgICAgICAgICAndHJhbnNmb3JtJywKICAgICAgICAgICAgICAgICAgICBgdHJhbnNsYXRlKCR7dGhpcy5zdmdQYWRkaW5nLmxlZnR9LCAke3RoaXMuc3ZnUGFkZGluZy50b3B9KWAKICAgICAgICAgICAgICAgICk7CgogICAgICAgICAgICB1bWFwR3JvdXAKICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2cnKQogICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2NvbnRvdXItZ3JvdXAnKQogICAgICAgICAgICAgICAgLmNsYXNzZWQoJ2hpZGRlbicsICF0aGlzLnNob3dDb250b3Vycyk7CgogICAgICAgIH0sCiAgICAgICAgaW5pdFRvcFN2ZygpIHsKCiAgICAgICAgICAgIC8vIOWIm+W7uuS4gOS4qiBTVkcg5YWD57Sg5bm26K6+572u5YW25bGe5oCnCiAgICAgICAgICAgIHRoaXMudG9wU3ZnID0gdGhpcy5jb21wb25lbnQuYXBwZW5kKCdzdmcnKQogICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgInRvcC1zdmciKQogICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgdGhpcy5zdmdGdWxsU2l6ZS53aWR0aCkgIC8vIOiuvue9ruWuveW6pgogICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIHRoaXMuc3ZnRnVsbFNpemUuaGVpZ2h0KSAvLyDorr7nva7pq5jluqYKCiAgICAgICAgICAgIGNvbnN0IHRvcFN2ZyA9IGQzLnNlbGVjdCgnLnRvcC1zdmcnKQogICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgYCR7dGhpcy5zdmdGdWxsU2l6ZS53aWR0aH1weGApCiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgYCR7dGhpcy5zdmdGdWxsU2l6ZS5oZWlnaHR9cHhgKTsKCiAgICAgICAgICAgIC8vIGNvbnN0IHRvcEdyb3VwID0gdG9wU3ZnLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ3RvcC1ncm91cCcpOwoKICAgICAgICAgICAgLy8gdG9wR3JvdXAKICAgICAgICAgICAgLy8gICAgIC5hcHBlbmQoJ3JlY3QnKQogICAgICAgICAgICAvLyAgICAgLmF0dHIoJ2NsYXNzJywgJ21vdXNlLXRyYWNrLXJlY3QnKQogICAgICAgICAgICAvLyAgICAgLmF0dHIoJ3dpZHRoJywgdGhpcy5zdmdGdWxsU2l6ZS53aWR0aCkKICAgICAgICAgICAgLy8gICAgIC5hdHRyKCdoZWlnaHQnLCB0aGlzLnN2Z0Z1bGxTaXplLmhlaWdodCk7CgogICAgICAgICAgICAvLyBjb25zdCB0b3BDb250ZW50ID0gdG9wR3JvdXAuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAndG9wLWNvbnRlbnQnKTsKCiAgICAgICAgICAgIC8vIHRvcENvbnRlbnQuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAndG9waWNzLWJvdHRvbScpOwogICAgICAgICAgICAvLyB0b3BDb250ZW50CiAgICAgICAgICAgIC8vICAgICAuYXBwZW5kKCdnJykKICAgICAgICAgICAgLy8gICAgIC5hdHRyKCdjbGFzcycsICd0b3BpY3MnKTsKICAgICAgICAgICAgLy8gdG9wQ29udGVudC5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICd0b3BpY3MtdG9wJyk7CiAgICAgICAgICAgIC8vIHRvcENvbnRlbnQuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnaGlnaGxpZ2h0cycpOwoKICAgICAgICB9LAogICAgICAgIHpvb21lZChlKSB7CiAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGUudHJhbnNmb3JtOwogICAgICAgICAgICBjb25zdCBzY2FsZUNoYW5nZWQgPSB0aGlzLmN1clpvb21UcmFuc2Zvcm0uayAhPT0gdHJhbnNmb3JtLms7CiAgICAgICAgICAgIHRoaXMuY3VyWm9vbVRyYW5zZm9ybSA9IHRyYW5zZm9ybTsKCiAgICAgICAgICAgIC8vID09PSBUYXNrICgxKSA9PT0KICAgICAgICAgICAgLy8gVHJhbnNmb3JtIHRoZSBTVkcgZWxlbWVudHMKICAgICAgICAgICAgdGhpcy5zdmcuc2VsZWN0KCcudW1hcC1ncm91cCcpLmF0dHIoJ3RyYW5zZm9ybScsIHRyYW5zZm9ybS50b1N0cmluZygpKTsKCiAgICAgICAgICAgIC8vIFRyYW5zZm9ybSB0aGUgdG9wIFNWRyBlbGVtZW50cwogICAgICAgICAgICB0aGlzLnRvcFN2ZwogICAgICAgICAgICAgICAgLnNlbGVjdCgnLnRvcC1ncm91cCcpCiAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgdHJhbnNmb3JtLnRvU3RyaW5nKCkpOwoKICAgICAgICAgICAgLy8gVHJhbnNmb3JtIHRoZSB2aXNpYmxlIGNhbnZhcyBlbGVtZW50cwogICAgICAgICAgICBpZiAodGhpcy5zaG93UG9pbnRzKSB7CiAgICAgICAgICAgICAgICBpZiAodGhpcy5mcm9udFBvc2l0aW9uQnVmZmVyICYmIHRoaXMuZnJvbnRUZXh0dXJlQ29vcmRpbmF0ZUJ1ZmZlcikgewogICAgICAgICAgICAgICAgICAgIGRyYXdTY2F0dGVyUGxvdCh0aGlzKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQoKICAgICAgICB9LAogICAgICAgIC8vIEV2ZW50IGhhbmRsZXIgZm9yIHpvb20gZW5kZWQKICAgICAgICB6b29tRW5kZWQoKSB7CiAgICAgICAgICAgIGNvbnNvbGUubG9nKCJzdmcgem9vbSBlbmQgISEhIikKICAgICAgICB9LAogICAgICAgIGluaXRXb3JrZXIoKSB7CiAgICAgICAgICAgIC8vIEluaXRpYWxpemUgdGhlIHdlYiB3b3JrZXIgdG8gbG9hZCBkYXRhIGFuZCBkZWFsIHdpdGggdGhlIHF1YWR0cmVlCiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1dvcmtlciBMb2FkZXIgV29ya2VyJywgTG9hZGVyV29ya2VyKTsKICAgICAgICAgICAgdGhpcy5sb2FkZXJXb3JrZXIgPSBuZXcgTG9hZGVyV29ya2VyKCk7CiAgICAgICAgICAgIGNvbnNvbGUubG9nKCLlr7kgTmV3IOeahOe7k+aenOi/m+ihjCAiLCB0aGlzLmxvYWRlcldvcmtlcikKICAgICAgICAgICAgdGhpcy5sb2FkZXJXb3JrZXIub25tZXNzYWdlID0gKGUpID0+IHsKICAgICAgICAgICAgICAgIHRoaXMubG9hZGVyV29ya2VyTWVzc2FnZUhhbmRsZXIoZSk7CiAgICAgICAgICAgIH07CgogICAgICAgICAgICB0aGlzLnRyZWVXb3JrZXIgPSBuZXcgVHJlZVdvcmtlcigpOwogICAgICAgICAgICB0aGlzLnRyZWVXb3JrZXIub25tZXNzYWdlID0gKGUpID0+IHsKICAgICAgICAgICAgICAgIHRoaXMudHJlZVdvcmtlck1lc3NhZ2VIYW5kbGVyKGUpOwogICAgICAgICAgICB9OwogICAgICAgIH0sCiAgICAgICAgbG9hZGVyV29ya2VyTWVzc2FnZUhhbmRsZXIoZSkgewogICAgICAgICAgICBzd2l0Y2ggKGUuZGF0YS5jb21tYW5kKSB7CiAgICAgICAgICAgICAgICBjYXNlICd0cmFuc2ZlckxvYWREYXRhJzogewogICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0aGVzZSBwb2ludHMgdG8gdGhlIHF1YWR0cmVlIEFTQVAKICAgICAgICAgICAgICAgICAgICBjb25zdCB0cmVlTWVzc2FnZSA9IHsKICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZDogJ3VwZGF0ZVF1YWR0cmVlJywKICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZDogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzOiBlLmRhdGEucGF5bG9hZC5wb2ludHMKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIH07CiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmVlV29ya2VyLnBvc3RNZXNzYWdlKHRyZWVNZXNzYWdlKTsKCiAgICAgICAgICAgICAgICAgICAgaWYgKGUuZGF0YS5wYXlsb2FkLmlzRmlyc3RCYXRjaCkgewogICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIGZpcnN0IGJhdGNoIHBvaW50cwogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb21wdFBvaW50cyA9IGUuZGF0YS5wYXlsb2FkLnBvaW50czsKCiAgICAgICAgICAgICAgICAgICAgICAgIGluaXRXZWJHTEJ1ZmZlcnMoKTsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFueVRydWUodGhpcy5zaG93UG9pbnRzKSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJhd1NjYXR0ZXJQbG90KCk7CiAgICAgICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgcG9pbnRzIHRvIHRoZSBzZWFyY2ggaW5kZXgKICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VhcmNoTWVzc2FnZSA9IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICdhZGRQb2ludHMnLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZDogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50czogZS5kYXRhLnBheWxvYWQucG9pbnRzCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIH07CiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMuc2VhcmNoV29ya2VyLnBvc3RNZXNzYWdlKHNlYXJjaE1lc3NhZ2UpOwogICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJhdGNoZXMgYWZ0ZXIgdGhlIGZpcnN0IGJhdGNoCiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgcG9pbnRzIHRvIHRoZSBwcm9tcHQgcG9pbnQgbGlzdAogICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdQb2ludHMgPSBlLmRhdGEucGF5bG9hZC5wb2ludHM7CiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcG9pbnQgb2YgbmV3UG9pbnRzKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb21wdFBvaW50cy5wdXNoKHBvaW50KTsKICAgICAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBwb2ludHMgdG8gdGhlIHNlYXJjaCBpbmRleAogICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zdCBzZWFyY2hNZXNzYWdlID0gewogICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgY29tbWFuZDogJ2FkZFBvaW50cycsCiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICBwYXlsb2FkOiB7CiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgcG9pbnRzOiBuZXdQb2ludHMKICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgLy8gfTsKICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcy5zZWFyY2hXb3JrZXIucG9zdE1lc3NhZ2Uoc2VhcmNoTWVzc2FnZSk7CgogICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIG5ldyBwb2ludHMgdG8gdGhlIFdlYkdMIGJ1ZmZlcnMKICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVXZWJHTEJ1ZmZlcnMobmV3UG9pbnRzKTsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFueVRydWUodGhpcy5zaG93UG9pbnRzKSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJhd1NjYXR0ZXJQbG90KCk7CiAgICAgICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLmRhdGEucGF5bG9hZC5pc0xhc3RCYXRjaCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0ZpbmlzaGVkIGxvYWRpbmcgYWxsIGRhdGEuJyk7CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgZGF0YSBwb2ludCBjb3VudAogICAgICAgICAgICAgICAgICAgIHRoaXMubG9hZGVkUG9pbnRDb3VudCA9IGUuZGF0YS5wYXlsb2FkLmxvYWRlZFBvaW50Q291bnQ7CgogICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgZm9vdGVyCiAgICAgICAgICAgICAgICAgICAgdGhpcy5mb290ZXJTdG9yZVZhbHVlLm51bVBvaW50cyA9IHRoaXMucHJvbXB0UG9pbnRzLmxlbmd0aDsKICAgICAgICAgICAgICAgICAgICB0aGlzLmZvb3RlclN0b3JlLnNldCh0aGlzLmZvb3RlclN0b3JlVmFsdWUpOwogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHsKICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdVbmtub3duIG1lc3NhZ2UnLCBlLmRhdGEuY29tbWFuZCk7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICB9LAogICAgICAgIHRyZWVXb3JrZXJNZXNzYWdlSGFuZGxlcihlKSB7CiAgICAgICAgICAgIHN3aXRjaCAoZS5kYXRhLmNvbW1hbmQpIHsKICAgICAgICAgICAgICAgIGNhc2UgJ2ZpbmlzaEluaXRRdWFkdHJlZSc6IHsKICAgICAgICAgICAgICAgICAgICAvLyBUZWxsIHRoZSBsb2FkZXIgd29ya2VyIHRvIHN0YXJ0IGxvYWRpbmcgZGF0YQogICAgICAgICAgICAgICAgICAgIC8vIChuZWVkIHRvIHdhaXQgdG8gc2V0IHVwIHRoZSBxdWFkdHJlZSB0byBhdm9pZCByYWNpbmcpCiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IHsKICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZDogJ3N0YXJ0TG9hZERhdGEnLAogICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkOiB7IHVybDogdGhpcy5kYXRhVVJMcy5wb2ludCB9CiAgICAgICAgICAgICAgICAgICAgfTsKICAgICAgICAgICAgICAgICAgICB0aGlzLmxvYWRlcldvcmtlci5wb3N0TWVzc2FnZShtZXNzYWdlKTsKICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICBjYXNlICdmaW5pc2hRdWFkdHJlZVNlYXJjaCc6IHsKICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5sYXN0TW91c2VDbGllbnRQb3NpdGlvbiA9PT0gbnVsbCkgewogICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xhc3RNb3VzZUNsaWVudFBvc2l0aW9uIGlzIG51bGwnKTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGNsb3Nlc3QgcG9pbnQgaXMgcmVsYXRpdmVseSBjbG9zZSB0byB0aGUgbW91c2UKICAgICAgICAgICAgICAgICAgICBjb25zdCBjbG9zZXN0UG9pbnQgPSBzdHJ1Y3R1cmVkQ2xvbmUoCiAgICAgICAgICAgICAgICAgICAgICAgIGUuZGF0YS5wYXlsb2FkLnBvaW50CiAgICAgICAgICAgICAgICAgICAgKTsKICAgICAgICAgICAgICAgICAgICBjb25zdCBzY3JlZW5Qb2ludFggPSB0aGlzLmN1clpvb21UcmFuc2Zvcm0uYXBwbHlYKAogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnhTY2FsZShjbG9zZXN0UG9pbnQueCkKICAgICAgICAgICAgICAgICAgICApOwogICAgICAgICAgICAgICAgICAgIGNvbnN0IHNjcmVlblBvaW50WSA9IHRoaXMuY3VyWm9vbVRyYW5zZm9ybS5hcHBseVkoCiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMueVNjYWxlKGNsb3Nlc3RQb2ludC55KQogICAgICAgICAgICAgICAgICAgICk7CgogICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5tYXgoCiAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguYWJzKHNjcmVlblBvaW50WCAtIHRoaXMubGFzdE1vdXNlQ2xpZW50UG9zaXRpb24ueCksCiAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguYWJzKHNjcmVlblBvaW50WSAtIHRoaXMubGFzdE1vdXNlQ2xpZW50UG9zaXRpb24ueSkKICAgICAgICAgICAgICAgICAgICApOwoKICAgICAgICAgICAgICAgICAgICBjb25zdCBoaWdobGlnaHRSYWRpdXMgPSBNYXRoLm1heCgKICAgICAgICAgICAgICAgICAgICAgICAgMTAgLyB0aGlzLmN1clpvb21UcmFuc2Zvcm0uaywKICAgICAgICAgICAgICAgICAgICAgICAgKGNvbmZpZy5sYXlvdXQuc2NhdHRlckRvdFJhZGl1cyAqCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLmV4cChNYXRoLmxvZyh0aGlzLmN1clpvb21UcmFuc2Zvcm0uaykgKiAwLjU1KSkgLwogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN1clpvb21UcmFuc2Zvcm0uawogICAgICAgICAgICAgICAgICAgICk7CgogICAgICAgICAgICAgICAgICAgIC8vIEhpZ2hsaWdodCB0aGUgcG9pbnQgaWYgaXQgaXMgY2xvc2UgZW5vdWdoIHRvIHRoZSBtb3VzZQogICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1ckhvdmVyUmFkaXVzID0gTWF0aC5tYXgoCiAgICAgICAgICAgICAgICAgICAgICAgIEhPVkVSX1JBRElVUywKICAgICAgICAgICAgICAgICAgICAgICAgaGlnaGxpZ2h0UmFkaXVzICogdGhpcy5jdXJab29tVHJhbnNmb3JtLmsKICAgICAgICAgICAgICAgICAgICApOwoKICAgICAgICAgICAgICAgICAgICBpZiAoZGlzdGFuY2UgPD0gY3VySG92ZXJSYWRpdXMpIHsKICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRQb2ludCh7IHBvaW50OiBjbG9zZXN0UG9pbnQsIGFuaW1hdGVkOiBmYWxzZSB9KTsKICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZ2hsaWdodFBvaW50KHsgcG9pbnQ6IHVuZGVmaW5lZCwgYW5pbWF0ZWQ6IGZhbHNlIH0pOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICBkZWZhdWx0OiB7CiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignVW5rbm93biBtZXNzYWdlJywgZS5kYXRhLmNvbW1hbmQpOwogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgfSwKICAgIH0sCiAgICBjb21wdXRlZDogewogICAgICAgIC4uLm1hcFN0YXRlKHsKICAgICAgICB9KSwKICAgIH0sCiAgICB3YXRjaDogewoKICAgICAgICByZWR1Y3Rpb25JbmZvKG5ld1ZhbCkgewogICAgICAgICAgICBpZiAobmV3VmFsICYmIG5ld1ZhbC5sZW5ndGgpIHsKICAgICAgICAgICAgICAgIHRoaXMucmVkdWN0aW9uRGF0YSA9IG5ld1ZhbDsKICAgICAgICAgICAgICAgIHRoaXMuZ3JpZERhdGEgPSB0aGlzLiRzdG9yZS5zdGF0ZS5ncmlkRGVuc2l0eTsKICAgICAgICAgICAgfQogICAgICAgIH0sCiAgICB9Cn07CgoK"},{"version":3,"sources":["DistributionView.vue"],"names":[],"mappings":";AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;;;;;AAKA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"DistributionView.vue","sourceRoot":"src/views/MainView/MiddleMainView","sourcesContent":["<template>\n    <div v-if=\"this.$store.state.isDone['DisT']\" class=\"distribution-main\" ref=\"distributionMain\">\n    </div>\n</template>\n\n\n<script>\nimport api from \"@/api/data\";\nimport * as THREE from 'three';\nimport { FontLoader } from 'three/examples/jsm/loaders/FontLoader';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\nimport { mapState } from \"vuex\";\nimport { config } from '@/config/config';\nimport createRegl from 'regl';\nimport d3 from '../../../utils/d3-import';\nimport { initWebGLMatrices, initWebGLBuffers, drawScatterPlot, drawGroupContour } from '../MiddleMainView/Embedding';\n// import { LoaderWorkerMessage } from '../../../../types/embedding-types';\nimport LoaderWorker from '../../../components/Embedding/workers/loader.worker?worker&inline';\nimport TreeWorker from '../../../components/Embedding/workers/tree.worker?worker&inline';\n\nexport default {\n    name: \"DistributionView\",\n    components: {\n\n    },\n    data() {\n        return {\n            component: null,    // HTMLElement： d3.select('.distribution-main')\n\n            svg: null,    // d3.Selection<HTMLElement, unknown, null, undefined>, unsed for drawing contour\n            svgFullSize: { width: 0, height: 0 },   // Size\n            svgSize: { width: 0, height: 0 }, // square draw \n            svgPadding: { top: 0, bottom: 0, left: 0, right: 0 }, // Padding\n\n            topSvg: null,   // d3.Selection<HTMLElement, unknown, null, undefined>, unsed for drawing hightlights\n            topicCanvases: [],  // used for drawing embedding points and others\n\n            // points\n            pointCanvas: null,\n            pointRegl: null,\n            frontPositionBuffer: null,\n            frontTextureCoordinateBuffer: null,\n            frontBufferPointSize: 0,\n\n            // search\n            searchPointCanvas: null,\n            searchPointRegl: null,\n\n            // setting\n            xScale: null,\n            yScale: null,\n\n            // scatter plot\n            webGLMatrices: null,\n            curPointWidth: 0,\n\n            curZoomTransform: null,\n\n            // data\n            gridData: null,\n            points: null,\n            loadedPointCount: 1,\n            reductionData: [],\n\n\n            // user settings\n            showContours: true,\n            showPoints: true,\n\n\n            // zooming\n            zoom: null, // d3.ZoomBehavior<HTMLElement, unknown>\n\n            // Web workers\n            loaderWorker: null,\n            treeWorker: null,\n\n\n        };\n    },\n    mounted() {\n\n        this.init();\n\n    },\n    methods: {\n        init() {\n            const dag = this.$refs.distributionMain;\n            this.svgFullSize.height = dag.clientHeight;\n            this.svgFullSize.width = dag.clientWidth;\n\n            this.component = d3.select('.distribution-main');\n\n            //\n            this.initTopSvg();\n\n            // Initialize the canvases\n            this.initCanvas();\n\n            // \n            this.initSVGGroups();\n\n            // Register zoom\n            this.zoom = d3\n                .zoom()\n                .extent([\n                    [0, 0],\n                    [this.svgSize.width, this.svgSize.height]\n                ])\n                .scaleExtent([config.layout.zoomScale[0], config.layout.zoomScale[1]])\n                .interpolate(d3.interpolate)\n                .on('zoom', (g) => {\n                    (async () => {\n                        await this.zoomed(g);\n                    })();\n                })\n                .on('end', () => this.zoomEnded());\n\n            this.topSvg.call(this.zoom).on('dblclick.zoom', null);\n\n\n            this.points = this.$store.state.reductionInfo;\n            this.gridData = this.$store.state.gridDensity;\n\n            const squareCanvasWidth = Math.min(\n                this.svgFullSize.width - this.svgPadding.left - this.svgPadding.right,\n                this.svgFullSize.height - this.svgPadding.top - this.svgPadding.bottom\n            );\n\n            this.svgSize = {\n                width: squareCanvasWidth,\n                height: squareCanvasWidth\n            };\n\n            // Initialize the data scales\n            const xRange = this.gridData.xRange;\n            const yRange = this.gridData.yRange;\n\n            // Force the plot to be a square\n            let xLength = xRange[1] - xRange[0];\n            let yLength = yRange[1] - yRange[0];\n\n            if (!this.gridData.padded) {\n                // Add padding for the data\n                if (xLength < yLength) {\n                    yRange[0] -= yLength / 50;\n                    yRange[1] += yLength / 50;\n                    yLength = yRange[1] - yRange[0];\n\n                    xRange[0] -= (yLength - xLength) / 2;\n                    xRange[1] += (yLength - xLength) / 2;\n                } else {\n                    // Add padding for the data\n                    xRange[0] -= xLength / 50;\n                    xRange[1] += xLength / 50;\n                    xLength = xRange[1] - xRange[0];\n\n                    yRange[0] -= (xLength - yLength) / 2;\n                    yRange[1] += (xLength - yLength) / 2;\n                }\n            }\n            this.xScale = d3\n                .scaleLinear()\n                .domain(xRange)\n                .range([0, this.svgSize.width]);\n\n            this.yScale = d3\n                .scaleLinear()\n                .domain(yRange)\n                .range([this.svgSize.height, 0]);\n\n            this.curZoomTransform = d3.zoomIdentity;\n\n            initWebGLMatrices(this); // 确保 this 指向 Vue 实例\n            initWebGLBuffers(this);\n            drawScatterPlot(this);\n\n            drawGroupContour(this);\n\n            this.initWorker();\n\n            const treeMessage = {\n            command: 'initQuadtree',\n            payload: {\n                xRange: xRange,\n                yRange: yRange,\n                groupIDs: null,\n                times: []\n            }\n            };\n            console.log(\"and post message to worker!!!\", treeMessage)\n\n\n\n            this.treeWorker.postMessage(treeMessage);\n\n\n\n\n        },\n        initCanvas() {\n\n            const discomponent = this.$refs.distributionMain;\n            this.pointCanvas = d3.select(discomponent)\n                .append('canvas')\n                .attr('class', 'embedding-canvas')\n                .attr('width', this.svgFullSize.width)\n                .attr('height', this.svgFullSize.height);\n\n            this.pointRegl = createRegl(this.pointCanvas?.node());\n\n            // this.searchPointCanvas = d3.select(discomponent)\n            //     .append('canvas')\n            //     .attr('class', 'search-point-canvas')\n            //     .attr('width', this.svgFullSize.width)\n            //     .attr('height', this.svgFullSize.height);\n\n            // this.searchPointRegl = createRegl(this.searchPointCanvas?.node());\n\n            // this.topicCanvases = [];\n            // for (const pos of ['top', 'bottom']) {\n            //     this.topicCanvases.push(\n            //         d3\n            //             .select(discomponent)\n            //             .append('canvas')\n            //             .attr('class', `topic-grid-canvas.${pos}`)\n            //             .attr('width', `${this.svgFullSize.width}px`)\n            //             .attr('height', `${this.svgFullSize.height}px`)\n            //     );\n            // }\n\n        },\n        initSVGGroups() {\n\n            this.svg = this.component.append('svg')\n                .attr('class', \"embedding-svg\")\n                .attr('width', this.svgFullSize.width)\n                .attr('height', this.svgFullSize.height);\n\n\n            const umapGroup = this.svg\n                .append('g')\n                .attr('class', 'umap-group')\n                .attr(\n                    'transform',\n                    `translate(${this.svgPadding.left}, ${this.svgPadding.top})`\n                );\n\n            umapGroup\n                .append('g')\n                .attr('class', 'contour-group')\n                .classed('hidden', !this.showContours);\n\n        },\n        initTopSvg() {\n\n            // 创建一个 SVG 元素并设置其属性\n            this.topSvg = this.component.append('svg')\n                .attr('class', \"top-svg\")\n                .attr('width', this.svgFullSize.width)  // 设置宽度\n                .attr('height', this.svgFullSize.height) // 设置高度\n\n            const topSvg = d3.select('.top-svg')\n                .attr('width', `${this.svgFullSize.width}px`)\n                .attr('height', `${this.svgFullSize.height}px`);\n\n            // const topGroup = topSvg.append('g').attr('class', 'top-group');\n\n            // topGroup\n            //     .append('rect')\n            //     .attr('class', 'mouse-track-rect')\n            //     .attr('width', this.svgFullSize.width)\n            //     .attr('height', this.svgFullSize.height);\n\n            // const topContent = topGroup.append('g').attr('class', 'top-content');\n\n            // topContent.append('g').attr('class', 'topics-bottom');\n            // topContent\n            //     .append('g')\n            //     .attr('class', 'topics');\n            // topContent.append('g').attr('class', 'topics-top');\n            // topContent.append('g').attr('class', 'highlights');\n\n        },\n        zoomed(e) {\n            const transform = e.transform;\n            const scaleChanged = this.curZoomTransform.k !== transform.k;\n            this.curZoomTransform = transform;\n\n            // === Task (1) ===\n            // Transform the SVG elements\n            this.svg.select('.umap-group').attr('transform', transform.toString());\n\n            // Transform the top SVG elements\n            this.topSvg\n                .select('.top-group')\n                .attr('transform', transform.toString());\n\n            // Transform the visible canvas elements\n            if (this.showPoints) {\n                if (this.frontPositionBuffer && this.frontTextureCoordinateBuffer) {\n                    drawScatterPlot(this);\n                }\n            }\n\n        },\n        // Event handler for zoom ended\n        zoomEnded() {\n            console.log(\"svg zoom end !!!\")\n        },\n        initWorker() {\n            // Initialize the web worker to load data and deal with the quadtree\n            console.error('Worker Loader Worker', LoaderWorker);\n            this.loaderWorker = new LoaderWorker();\n            console.log(\"对 New 的结果进行 \", this.loaderWorker)\n            this.loaderWorker.onmessage = (e) => {\n                this.loaderWorkerMessageHandler(e);\n            };\n\n            this.treeWorker = new TreeWorker();\n            this.treeWorker.onmessage = (e) => {\n                this.treeWorkerMessageHandler(e);\n            };\n        },\n        loaderWorkerMessageHandler(e) {\n            switch (e.data.command) {\n                case 'transferLoadData': {\n                    // Add these points to the quadtree ASAP\n                    const treeMessage = {\n                        command: 'updateQuadtree',\n                        payload: {\n                            points: e.data.payload.points\n                        }\n                    };\n                    this.treeWorker.postMessage(treeMessage);\n\n                    if (e.data.payload.isFirstBatch) {\n                        // Add the first batch points\n                        this.promptPoints = e.data.payload.points;\n\n                        initWebGLBuffers();\n                        if (anyTrue(this.showPoints)) {\n                            drawScatterPlot();\n                        }\n\n                        // Add the points to the search index\n                        const searchMessage = {\n                            command: 'addPoints',\n                            payload: {\n                                points: e.data.payload.points\n                            }\n                        };\n                        // this.searchWorker.postMessage(searchMessage);\n                    } else {\n                        // Batches after the first batch\n                        // Add the points to the prompt point list\n                        const newPoints = e.data.payload.points;\n                        for (const point of newPoints) {\n                            this.promptPoints.push(point);\n                        }\n\n                        // Add the points to the search index\n                        // const searchMessage = {\n                        //     command: 'addPoints',\n                        //     payload: {\n                        //         points: newPoints\n                        //     }\n                        // };\n                        // this.searchWorker.postMessage(searchMessage);\n\n                        // Add the new points to the WebGL buffers\n                        this.updateWebGLBuffers(newPoints);\n                        if (anyTrue(this.showPoints)) {\n                            drawScatterPlot();\n                        }\n\n                        if (e.data.payload.isLastBatch) {\n                            console.log('Finished loading all data.');\n                        }\n                    }\n\n                    // Update the data point count\n                    this.loadedPointCount = e.data.payload.loadedPointCount;\n\n                    // Update the footer\n                    this.footerStoreValue.numPoints = this.promptPoints.length;\n                    this.footerStore.set(this.footerStoreValue);\n                    break;\n                }\n\n                default: {\n                    console.error('Unknown message', e.data.command);\n                    break;\n                }\n            }\n        },\n        treeWorkerMessageHandler(e) {\n            switch (e.data.command) {\n                case 'finishInitQuadtree': {\n                    // Tell the loader worker to start loading data\n                    // (need to wait to set up the quadtree to avoid racing)\n                    const message = {\n                        command: 'startLoadData',\n                        payload: { url: this.dataURLs.point }\n                    };\n                    this.loaderWorker.postMessage(message);\n                    break;\n                }\n\n                case 'finishQuadtreeSearch': {\n                    if (this.lastMouseClientPosition === null) {\n                        throw new Error('lastMouseClientPosition is null');\n                    }\n                    // Check if the closest point is relatively close to the mouse\n                    const closestPoint = structuredClone(\n                        e.data.payload.point\n                    );\n                    const screenPointX = this.curZoomTransform.applyX(\n                        this.xScale(closestPoint.x)\n                    );\n                    const screenPointY = this.curZoomTransform.applyY(\n                        this.yScale(closestPoint.y)\n                    );\n\n                    const distance = Math.max(\n                        Math.abs(screenPointX - this.lastMouseClientPosition.x),\n                        Math.abs(screenPointY - this.lastMouseClientPosition.y)\n                    );\n\n                    const highlightRadius = Math.max(\n                        10 / this.curZoomTransform.k,\n                        (config.layout.scatterDotRadius *\n                            Math.exp(Math.log(this.curZoomTransform.k) * 0.55)) /\n                        this.curZoomTransform.k\n                    );\n\n                    // Highlight the point if it is close enough to the mouse\n                    const curHoverRadius = Math.max(\n                        HOVER_RADIUS,\n                        highlightRadius * this.curZoomTransform.k\n                    );\n\n                    if (distance <= curHoverRadius) {\n                        this.highlightPoint({ point: closestPoint, animated: false });\n                    } else {\n                        this.highlightPoint({ point: undefined, animated: false });\n                    }\n                    break;\n                }\n\n                default: {\n                    console.error('Unknown message', e.data.command);\n                    break;\n                }\n            }\n        },\n    },\n    computed: {\n        ...mapState({\n        }),\n    },\n    watch: {\n\n        reductionInfo(newVal) {\n            if (newVal && newVal.length) {\n                this.reductionData = newVal;\n                this.gridData = this.$store.state.gridDensity;\n            }\n        },\n    }\n};\n\n\n</script>\n\n<style lang=\"scss\">\n@use './DistributionView.scss';\n</style>"]}]}